---
title: 《C++ Primer Plus》阅读笔记
cover: assets/cppPrimerPlus.png
categories:
- [C++]
tags:
  - C++
---

# 第1章 预备知识

C++在C语言的基础上添加了对面向对象编程和泛型编程的支持。 C++继承了 C 语言高效、 简洁、 快速和<u>可移植性</u>的传统。 C++面向对象的特性带来了全新的编程方法，这种方法是为应付复杂程度不断提高的现代编程任务而设计的。 C++的模板特性提供了另一种全新的编程方法——泛型编程。 

> 在计算机科学中，“可移植性”是指软件或代码能够在不同的计算机系统、操作系统或硬件平台上运行的能力。具体来说，在 C++ 中，可移植性意味着用 C++ 编写的程序可以在不同的环境中（如不同的操作系统或不同的硬件架构）进行编译和运行，而不需要进行大量的修改或重写代码

## 1.1 C++简介

C++融合了3种不同的编程方式: C语言代表的过程性语言、 C++在C语言基础上添加的类代表的面向对象语言、 C++模板支持的泛型编程。

## 1.2 C++简史

在 20 世纪 70 年代， C 和 Pascal 这样的语言引领人们进入了<u>结构化编程</u>时代， 这种机制把秩序和规程带进了迫切需要这种性质的领域中。 除了提供结构化编程工具外， C 还能生成简洁、 快速运行的程序， 并提供了处理硬件问题的能力， 如管理通信端口和磁盘驱动器。 这些因素使 C 语言成为 20 世纪 80 年代占统治地位的编程语言。 同时， 20 世纪 80 年代， 人们也见证了一种新编程模式的成长：面向对象编程 (OOP)。SmallTalk 和 C++语言具备这种功能。 下面更深入地介绍 C 和 OOP。

> 结构化编程是一种编程范式，它强调使用控制结构（如顺序、选择和循环）来组织程序的逻辑，而不是依赖于goto语句等不良编程习惯。其主要目标是提高程序的可读性、可维护性和可理解性。结构化编程通常包括以下几个关键特征：
>
> 1. **模块化**：将程序分解为小的、可管理的模块或函数，每个模块完成特定的任务。这使得程序更易于理解和维护。
> 2. **控制结构**：使用明确的控制结构（如if-else、for、while等）来控制程序的执行流程，而不是使用goto语句。这有助于减少程序的复杂性。
> 3. **自顶向下设计**：从高层次的功能开始设计程序，然后逐步细化到具体的实现。这种方法有助于清晰地定义程序的结构和功能。
> 4. **数据结构**：强调使用数据结构来组织和管理数据，使得程序能够更有效地处理信息。
>
> 结构化编程的出现使得程序员能够编写出更清晰、更易于维护的代码，促进了软件开发的规范化和标准化。

### 1.2.1 C语言

20 世纪 70 年代早期， 贝尔实验室的 Dennis Ritchie 致力于开发 UNIX 操作系统。 为完成这项工作， Ritchie 需要一种语言， 它必须简洁， 能够生成简洁、 快速的程序， 并能有效地控制硬件。

传统上， 程序员使用汇编语言来满足这些需求， 汇编语言依赖于计算机的内部机器语言。 然而， 汇编语言是低级 (low-level) 语言， 即直接操作硬件， 如直接访问 CPU 寄存器和内存单元。 因此汇编语言针对于特定的计算机处理器， 要将汇编程序移植到另 一种计算机上， 必须使用不同的汇编语言重 新编写程序。

然而， UNIX 是为在不同的计算机(或平台) 上工作而设计的， 这意味着它是一种高级语言。 高级 (high-level) 语言致力千解决问题， 而不针对特定的硬件。 一种被称为编译器的特殊程序将高级语言翻译 成特定计算机的内部语言。 这样， 就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了。 Ritchie 希望有一种语言能将低级语言的效率、 硬件访问能力和高级语言的通用性、 可移植性融合在一起， 于是他在旧语言的基础上开发了C语言。

### 1.2.2 C语言编程原理

由千 C吁在 C 语言的基础上移植了新的编程理念， 因此我们首先来看一看 C 所遵循的旧的理念。一般来说， 计算机语言要处理两个概念——数据和算法。 数据是程序使用和处理的信息， 而算法是程序使用的方法

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411181643448.png)

C 语言与当前最主流的语言一样， 在最初面世时也是过程性 (procedural) 语言， 这意 味着它强调的是编程的算法方面。 从概念上说， 过程化编程首先要确定计算机应采取的操作， 然后使用编 程语言来实现这些操作。 程序命令计算机按一系列流程生成特定的结果

随着程序规模的扩大， 早期的程序语言(如 FORTRAN 和 BASIC) 都会遇到组织方面的问题。 例 如， 程序经常使用分支语句， 根据某种测试的结果， 执行一组或另 一组指令。 很多旧式程序的执行路 径很混乱(被称为 “ 意大利面条式编程 ” )， 几乎不可能通过阅读程序来理解它，修改这种程序简直是一 场灾难。为了解决这种问题，计算机科学家开发了 一 种更有序的编程方法——结构化编程 (structured programming)。 C 语言具有使用这种方法的特性。 例如， 结构化编程将分支(决定接下来应执行哪个指令)限制为一小组行为良好的结构。 C 语言的词汇表中就包含了这些结构 (for 循环、while循环、 do while 循环和 if else 语句)。

另一个新原则是自顶向下 (top-down) 的设计。在C语言中，其理念是将大型程序分解成小型、 便于管理的任务。 如果其中的一项任务仍然过大， 则将它分解为更小的任务。这一过程将一 直持续下去， 直到将程序划分为小型的、 易于编写的模块。C语言的设计有助 于使用这种方法，它鼓励程序员开发程序单元(函 数)来表示各个任务模块。 如上所述， 结构化编 程技术反映了过程性编程的思想， 根据执行的操作来构思一个程序。

### 1.2.3 面向对象编程

虽然结构化编程的理念提高了程序的清晰度、 可靠性， 并使之便于维护， 但它在编写大型程序时， 仍面临着挑战。为应付这种挑战，OOP 提供了一种新方法。与强调算法的过程性编程不同的是，OOP 强调的是数据。OOP 不像过程性编程那样， 试图使问题满足语言的过程性方法， 而是试图让语言来满足问题的要求。 其理念是设计与问题的本质特性相对应的数据格式。

在C++中， 类是一种规范， 它描述了这种新型数据格式， 对象是根据这种规范构造的特定数据结构。 例如， 类可以描述公司管理人员的基本特征(姓名、 头衔、 工资、特长等)， 而对象则代表特定的管理人员 (Guilford Sheepblat、 副总裁、 $925 000、 知道如何恢复 Windows 注册表)。 通常， 类规定了可使用哪些数 据来表示对象以及可以对这些数据执行哪些操作。 例如， 假设正在开发 一个能够绘制矩形的计算机绘图程 序， 则可以定义一个描述矩形的类。 定义的数据部分应包括顶点的位置、 长和宽、 4条边的颜色和样式、 矩形内部的填充颜色和图案等; 定义的操作部分可以包括移动、 改变大小、 旋转、 改变颜色和图案、 将矩形复制到另一个位置上等操作。 这样， 当使用该程序来绘制矩形时， 它将根据类定义创建一个对象。该对 象保存了描述矩形的所有数据值， 因此可以使用类方法来修改该矩形。 如果绘制两个矩形， 程序将创建两 个对象， 每个矩形对应一个。

OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。例如，除了表示矩形的类外，绘图程序还可能定义表示直线、圆、画刷、画笔的类。 类定义描述了对每个类可执行的操作， 如移动圆或旋转直线。 然后便可以设计一个使用这些类的对象的程序。从低级组织(如类)到高级组织(如程序) 的处理过程叫做自下向上 (bottom-up) 的编程。

OOP 编程并不仅仅是将数据和方法合并为类定义。例如， OOP 还有助千创建可重用的代码，这将减少大量的工作。 信息隐藏可以保护数据， 使其免遭不适当的访问。 多态让您能够为运算符和函数创建多个定义， 通过编程上下文来确定使用哪个定义。继承让您能够使用旧类派生出新类。OOP 引入了很多新的理念， 使用的编程方法不同于过程性编程。它不是将重点放在任务上， 而是放在表示概念上。有时不一定使用自上向下的编程方法， 而是使用自下向上的编程方法。

设计有用、 可靠的类是一项艰巨的任务，幸运的是， OOP语言使程序员在编程中能够轻松地使用已有 的类。 厂商提供了大量有用的类库， 包括设计用千简化 Wmdows 或 Macintosh 环境下编程的类库。 C++真正的优点之一 是: 可以方便地重用和修改现有的、 经过仔细测试的代码。

### 1.2.4 C++和泛型编程

泛型编程(generic programming) 是C++支待的另 一种编程模式 。 它与OOP的目标相同 ， 即使重用 代码和抽象通用概念的技术 更简单。 不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。OOP是一个管理大型项目的工具，而泛型编程 提供了执行常见 任务(如 对数据排序或合并链表) 的工具。 术语泛型(generic)指的是创建独立千类型的代码。 C++的数据表示有多种类型——整数、 小数、 字符、 字符串、 用户定义的、 由多种类型组成的复合结构。 例如， 要对不同类型的数据进行排序， 通常必须为每种类型创建 一个排序函数 。 泛型编程需要对语言进行扩展， 以便可以只编写一个泛型(即不是特定类型的) 函数 ， 并将其用千各种实际类型 。 C++模板提供了完成这种任务的机制。

### 1.2.5 C++的起源

与C语言一样，C++也是在贝尔实验室诞生的， Bjame Stroustrup于 20 世纪 80 年代在这里开发 出了这种语言 。 用他自己的话来说， “C++主要是为了我 的朋友和我不 必再使用汇编语言、 C语言或其他现代高级语言来编程而设计的 。 它的 主要功能是可以 更方便地编写出好程序， 让每个程序员更加快乐 ” 。

Stroustrup比较关心的是让C++更有用 ， 而不是实施特定的编程原理或风格。 在确定C++语言特性方面 ，真正的编程需要比纯粹的原理更重要。 Stroupstrup之所以在C的基础上创建C++， 是因为C语言简洁、 适合系统编程、 使用广泛且与UNIX操作系统联系紧密 。 C++的OOP方面是受到了计算机模拟语言Simula67的启发。 Stroustrup加入了OOP特性和对C的泛型编程支待， 但并没有对C的组件作很大的改动。 因此，C++是C语言的超集，这意味着任何有效的C程序都是有效的C++程序。它们之间有些细微的差异，但无足轻重 。 C++程序可以使用已有的C软件库。 库是编程模块的集合， 可以从程序中调用它们。 库对很多常见的编程问题提供了可靠的解决方法， 因此能节省程序员大量的时间和工作量 。 这也有助于C++的广泛传播。

名称C++来自C语言中的递增运算符 ++， 该运算符将变量加1。 名称C++表明 ，它是C的扩充版本。

计算机程序将实际问题转换为计算机能够执行的一系列操作。<u>OOP部分赋予了C++语言将问题所涉及的概念联系起来的能力 ， C部分则赋予了C++语言紧密联系硬件的能力</u>， 这种能力上的结合成就了C++的广泛传播。

>  C++的二重性：
>
> 1. OOP提供了高级抽象。
>
>    ```cpp
>    ....
>    north_america.show();
>    ....
>    ```
>
> 2. C提供了低级硬件访问。
>
>    ```c
>    set byte at
>      address
>    01000 to 0
>    ```

## 1.3 可移植性和标准

假设您为运行Windows2000的老式奔腾PC 编写了一个很好用的C丹程序，而管理人员决定用使用不 同操作系统(如Mac OSX或Linux)和处理器(如SPARC 处理器) 的计算机替换它。 该程序是否可以在 新平台上运行呢?当然，必须使用为新平台设计的C++编译器对程序重新编译。 但是否需要修改编写好的代码呢?如果在不修改代码的情况下，重新编译程序后，程序将运行良好，则该程序是可移植的。

在可移植性方面存在两个障碍，其中的一个是硬件。<u>硬件特定的程序是不可移植的。例如， 直接控制 IBM PC视频卡的程序在涉及Sun时将 “ 胡言乱语“</u>(将依赖于硬件的部分放在函数模块中可以最大限度地降低可移植性问题；这样只需重新编写这些模块即可)。

> 如果一个程序是针对特定硬件（如IBM PC的视频卡）编写的，那么它可能无法在其他硬件平台（如Sun计算机）上正常运行。这是因为不同的硬件有不同的架构、接口和功能，直接与特定硬件交互的程序通常依赖于该硬件的特性和指令集。
>
> 例如，IBM PC的视频卡可能使用特定的命令和数据格式来控制显示，而Sun计算机的视频卡则可能使用完全不同的命令和格式。因此，直接控制IBM PC视频卡的程序在Sun计算机上运行时，可能会产生无法理解的输出或“胡言乱语”，因为它无法正确与Sun的硬件进行交互。

可移植性的第二个障碍是语言上的差异。 口语确实可能产生问题。 约克郡的人对某个事件的描述， 布 鲁克林人可能就听不明白，虽然这两个地方的人都说英语。 计算机语言也可能出现方言。WindowsXP C++的实现与Red Hat Linux 或Macintosh OSX实现相同吗?虽然多数实现都希望其C扞版本与其他版本兼容， 但如果没有准确描述语言工作方式的公开标准，这将很难做到。因此，美国国家标准局(American National Standards Institute, ANSI)在1990年设立了一 个委员会(ANSI X3Jl6)， 专门负责制定C++标准(ANSI 制定了C 语言标准)。 国际标准化组织(ISO)很快通过自己的委员会(ISO- WG-21) 加入了这个行列， 创建了联合组织ANSI/ISO, 致力于制定C++标准。

经过多年的努力，制定出了一 个国际标准 ISO/IEC 41 882: 1998, 并于1998 年获得了ISO 、 IEC(InternationalElectrotechnicalCommittee, 国际电工技术委员会)和ANSI 的批准。该标准常被称为==C++98==,它不仅描述了已有的 C++特性， 还对该语言进行了扩展，==添加了异常、 运行阶段类型识别(RTTI)、 模板和标准模板库(STL)==。2003 年， 发布了C++标准第二版(IOS/IEC 14882:2003);这个新版本是一 次技术性修订， 这意味着它对第一版进行了整理——修订错误、 减少多义性等， 但没有改变语言特性。 这个版本常被称为C++03。 由于==C++03 没有改变语言特性，因此使用C++98表示C++98/C++2003==。

C++在不断发展。ISO 标准委员会于2001年 8月批准了新标准ISO/IEC 14882: 20 11, 该标准以前称为C++11 。 与C++98 一样，==C++11==也==新增了众多特性==。 另外， 其==目标是消除不一致性， 让C++学习和使用起来更容易==。该标准还==曾被称为C++0x==, 最初预期x为7或8,但标准制定工作是一个令人疲惫的缓慢过程。所幸的是， 可将0x视为十六进制数， 这意味着委员会只需在2015年前完成这项任务即可。 根据这个度量标准，委员会还是提前完成了任务。

lSO C+＋标准还吸收了ANSI C语言标准， 因为C++应尽量是C 语言的超集。 这意味着在理想情况下，任何有效的C程序都应是有效的 C++程序。ANSI C与对应的C++规则之间存在一些差别， 但这种差别很小。 实际上， ANSI C加入了C++首次引入的一些特性， 如<u>函数原型</u>和类型限定符const。

> 函数原型是C和C++编程语言中的一个重要概念，它用于在函数的实际定义之前声明函数的名称、返回类型和参数类型。函数原型的主要作用是告诉编译器函数的基本信息，以便在调用该函数时，编译器可以检查传递给函数的参数类型是否与函数原型中声明的类型匹配。
>
> **函数原型的基本语法**
>
> ```cpp
> 返回类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...);
> ```
>
> **示例**
>
> ```cpp
> int add(int a, int b); // 函数原型
> ```
>
> 在这个例子中，`add`是函数的名称，返回类型是`int`，它接受两个`int`类型的参数。

在ANSI C出现之前， C语言社区遵循一种事实标准， 该标准基于Kernighan和Ritchie编写的《The C Programmling Language》 一书， 通常被称为K&R C; ANSI C出现后， 更简单的K&R C有时被称为经典C(C lassicC)。

ANSI C标准不仅定义了C语言，还定义了一个ANSI C实现必须支持的标准C库。C++也使用了这个库; 本书将其称为标准C库或标准库。 另外， ANSI/ISO C++标准还提供了一个C++标准类库。

==最新的C标准为C99==, ISO和ANSI分别于1999年和2000年批准了该标准。 该标准==在C语言中添加了一些C++编译器支持的特性， 如<u>新的整型</u>==。

> C99标准通过引入这些新的整型类型，增强了C语言的数值处理能力，使得程序员能够更精确地控制数据的大小和范围。这些新特性使得C语言在处理不同平台和硬件时更加灵活和可靠。这些新整型主要包括：
>
> **1. `long long int`**
>
> - **描述**：这是一个新的整型类型，至少保证有64位的范围。它用于处理比`long int`更大的整数。
>
> - **示例：**
>
>   ```cpp
>   long long int largeNumber = 9223372036854775807; // 最大值
>   ```
>
> **2. `int8_t`, `int16_t`, `int32_t`, `int64_t`**
>
> - **描述**：这些是固定宽度的整型类型，分别表示8位、16位、32位和64位的有符号整数。它们在`<stdint.h>`头文件中定义，提供了跨平台的一致性。
>
> - **示例：**
>
>   ```cpp
>   #include <stdint.h>
>       
>   int8_t smallNumber = 127;   // 8位有符号整数
>   int16_t mediumNumber = 32767; // 16位有符号整数
>   int32_t largeNumber = 2147483647; // 32位有符号整数
>   int64_t veryLargeNumber = 9223372036854775807; // 64位有符号整数
>   ```
>
> **3. `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t`**
>
> - **描述**：这些是固定宽度的无符号整型类型，分别表示8位、16位、32位和64位的无符号整数。
>
> - **示例：**
>
>   ```cpp
>   uint8_t smallUnsignedNumber = 255; // 8位无符号整数
>   uint16_t mediumUnsignedNumber = 65535; // 16位无符号整数
>   uint32_t largeUnsignedNumber = 4294967295; // 32位无符号整数
>   uint64_t veryLargeUnsignedNumber = 18446744073709551615; // 64位无符号整
>   ```

### 1.3.2 本书遵循的C++标准

当代的编译器都对C++98提供了很好的支持。 编写本书期间， 有些编译器还支持一些C++特性;随着新标准获批， 对这些特性的支持将很快得到提高。 本书反映了当前的情形， 详尽地介绍了C++98, 并涵盖 了C++11新增的一些特性。 在探讨相关的C++98主题时顺便介绍了一些C++新特性， 而第18章专门介绍 新特性， 它总结了本书前面提到的一些特性， 并介绍了其他特性。

在编写本书期间， 对C++ 11的支持还不全面， 因此难以全面介绍C++11新增的所有特性。考虑到篇幅限制， 即使这个新标准获得了全面支持，也无法在一本书中全面介绍它。 本书重点介绍大多数编译器都支持的特性， 并简要地总结其他特性。

详细介绍C++之前， 先介绍一些有关程序创建的基本知识。

## 1.4 程序创建的技巧

假设您编写了 一个C开程序。 如何让它运行起来呢?具体的步骤取决于计算机环境和使用的C++编译器， 但大体如下

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411181837996.png)

1. 使用文本编辑器编写程序， 并将其保存到文件中， 这个文件就是程序的源代码。
2. 编译源代码。 这意味着运行一个程序， 将源代码翻译为主机使用的内部语言机器语言。 包含了翻译后的程序的文件就是程序的目标代码(object code)。
3. 将目标代码与其他代码链接起来。 例如， C++程序通常使用库。 C++库包含一系列计算机例程(被称为函数)的目标代码， 这些函数可以执行诸如在屏幕上显示信息或计算平方根等任务。 链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码(startup code)组合起来， 生成程序的运行阶段版本。 包含该最终产品的文件被称为可执行代码。

### 1.4.1 创建源代码文件

有些 C++ 实现 (如Microsoft Visual C++、 Embarcadero C++Builder、 Apple Xcode、 Open Watcom C++、 Digital Mars C++和 Freescale CodeWarrior) 提供了集成开发环境 (integrated development envirorunents, IDE)， 让您能够在主程序中管理程序开发的所有步骤，包括编辑。  

有些实现(如用于 UNIX 和 Linux 的 GNU C++、 用于 AIX 的 IBM XL C/C++、 Embarcadero 分发的Borland 5.5 免费版本以及 Digital Mars 编译器)只能处理编译和链接阶段，用户需要在系统命令行中输入命令来进行编译和链接。在这种情况下， 可以使用任何文本编辑器来创建和修改源代码。 例如， 在 UNIX 系统上， 可以使用 vi、 ed、 ex 或 emacs; 在以命令提示符模式运行的 Windows 系统上， 可以使用 edlin、 edit 或任何程序编辑器。如果将源代码文件保存为<u>标准 ASCII 文本文件</u>(而不是<u>特殊的字处理器格式</u>)， 甚至可以使用<u>字处理器</u>。

> - 标准 ACSCII 文本文件：仅包含 ASCII 字符（如字母、数字、标点符号等）的文本文件。这种文件格式简单、可读性强，且可以在不同的操作系统和文本编辑器之间无缝传输
> - 特殊的字处理器格式：字处理器（如 Microsoft Word、WPS Office 等）通常用于创建和编辑文档，支持丰富的格式（如字体、颜色、段落样式等）。这些文档通常以特定的格式保存（如 `.doc`、`.docx`），而不是简单的文本。这些格式包含了大量的格式信息，可能不被编译器识别，因此不适合用于源代码的保存。
> - 字处理器：一种软件应用程序，用于创建、编辑和格式化文本文件。常见的字处理器包括 Microsoft Word、Google Docs 和 LibreOffice Writer。它们提供了丰富的文本格式化功能，但不适合用于编写源代码

另外，还可能有IDE选项， 让您能够使用这些命令行编译器。

> 某些集成开发环境（IDE）可能提供功能，使得用户可以在IDE内部直接使用命令行编译器的功能，而不需要手动切换到命令行界面。这种集成可以让开发者在一个统一的环境中进行代码编写、编译和调试，从而提高开发效率

给源文件命名时， 必须使用正确的后缀，将文件标识为 C++文件。这不仅告诉您该文件是 C++源代码， 还将这种信息告知编译器(如果 UNIX 编译器显示信息 ” bad magic number",
 则表明后缀不正确)。 后缀由一个句点和一个或多个字符组成， 这些字符被称作扩展名

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411181922467.png)

使用什么扩展名取决于 C++实现， 表 1.1 列出了一些常用的扩展名。 例如， spiffy.C 是有效的 UNIXC++源代码文件名。 注意， UNIX区分大小写， 这意味着应使用大写的C字符。实际上，<u>小写 c 扩展名也有效</u>， 但标准 C 才使用小写的c。 因此， 为避免在 UNIX 系统上发生混淆， 对于 C 程序应使用 c, 而对于 C++程序则请使用C。如果不在乎多输入一两个字符，则对于某些 UNlX系统， 也可以使用扩展名 cc 和 cxx。 

> 在 UNIX 系统上，虽然标准 C 语言使用小写的 `.c` 作为源文件扩展名，但实际上，使用小写的 `.c` 作为 C++ 源文件的扩展名也是有效的。这意味着您可以将 C++ 源代码文件命名为 `.c`，而不会导致编译错误

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411181936602.png)

<u>DOS</u> 比 UNIX 稍微简单一点，不区分大小写，因此DOS实现使用额外的字母来区别C和C++程序

> **DOS**（Disk Operating System）是一种操作系统，最初是为个人计算机设计的。它是一个命令行界面的操作系统，用户通过输入命令来执行各种操作，如文件管理、程序运行等
>
> DOS使用不同的扩展名来区分源代码文件，例如`.c`用于C程序，`.cpp`或`.cxx`用于C++程序

### 1.4.2 编译和链接

最初， Strosutrpu 实现C++时， 使用了一个 C++到C的编译器程序，而不是开发直接的 C++到目标代码的编译器。 前者叫做cfront (表示C前端， C front end )， 它将C++源代码翻译成 C源代码， 然后使用一个标准C编译器对其进行编译。<u>这种方法简化了向C的领域引入 C++的过程</u>。其他实现也采用这种方法将 C++引入到其他平台。随着C++的日渐普及，越来越多的实现转向创建C++编译器，直接将C++源代码生成目标代码。这种直接方法加速了编译过程，并强调C++是一种独立(虽然有些相似) 的语言。

> 使用 C++ 到 C 的编译器（如 cfront）可以更容易地将 C++ 语言引入到已经存在的 C 语言环境中

1. UNIX编译和链接

   最初，UNIX命令CC调用cfront , 但cfront 未能紧跟C++的发展步伐， 其最后一个版本发布于1993 年。当今的UNIX计算机可能没有编译器、 有专用编译器或第三方编译器，这些编译器可能是商业的，也可能是自由软件，如GNU g++编译器。如果UNIX计算机上有 C++编译器，很多情况下命令CC仍然管用， 只是启动的编译器随系统而异。出于简化的目的， 读者应假设命令CC可用， 但 必须认识到这 一 点， 即对于下述讨论中的CC，可能必须使用其他命令来 代替。

   请用CC命令来编译程序。名称采用大写字母，这样可以将它与标准UNIX C编译器cc 区分开 来。 CC编译器是命令行编译器， 这意味着需要在UNIX命令行上输入编译命令。

   例如， 要编译 C++源代码文件spiffy.C, 则应在UNIX提示符下输入如下命令:

   `CC spiffy.C`

   如果程序没有错误，编译器将生成一个扩展名为o的目标代码文件。在这个例子中， 编译器将生成文件spiffy.o。

   接下来， 编译器自动将目标代码文件传递给系统链接程序， 该程序将代码与库代码结合起来， 生成一个可执行文件。 在默认情况下， 可执行文件为 a.out。如果只使用一个源文件， 链接程序还将删除 spiffy.o文件， 因为这个文件不再需要了。 要运行该程序， 只要输入可执行文件的文件名即可:

   `a.out`

   如果编译新程序， 新的可执行文件a.out将覆盖已有的a.out(这是因为可执行文件占据了大量空间， 因此覆盖旧的可执行文件有助于降低存储需求)。 然而， 如果想保留可执行文件， 只需使用 UNIX 的mv命令来修改可执行文件的文件名即可。

   在 C++中，程序也可以包含多个文件。在这种情况下， 可以通过在命令行上列出全部文件来编译程序:

   `CC my.C precious.C`

   如果有多个源代码文件， 则编译器将不会删除目标代码文件。 这样， 如果只修改了 my.C 文件， 则可以用下面的命令重新编译该程序:

   `CC my.C precious.o`

   这将重新编译 my.C文件， 并将它与前面编译的 precious.o文件链接起来。

   > 在 C++ 中，程序通常由多个源文件组成，每个源文件可以定义不同的类、函数或其他程序结构。将这些源文件编译成目标文件（`.o` 文件）后，链接它们是为了生成一个完整的可执行程序
   >
   > 1. **模块化设计**
   >
   >    - **分离功能**：将程序分成多个源文件（如 `my.C` 和 `precious.C`）可以使代码更易于管理和维护。每个文件可以专注于特定的功能或模块。
   >
   >    - **重用性**：如果 `precious.C` 中的代码在多个项目中使用，可以将其编译为 `precious.o`，然后在其他项目中链接这个目标文件，而不需要重复编写相同的代码。
   >
   > 2. **编译和链接过程**
   >
   >    - **编译**：当你编译 `my.C` 和 `precious.C` 时，编译器会分别生成 `my.o` 和 `precious.o`。这两个目标文件包含了各自源文件中定义的函数和类的机器代码。
   >    - **链接**：在链接阶段，链接器会将 `my.o` 和 `precious.o` 中的代码结合起来，解决它们之间的引用关系。例如，如果 `my.C` 中的某个函数调用了 `precious.C` 中的一个函数，链接器会确保在最终的可执行文件中正确地连接这些调用。
   >
   > 3. **依赖关系**
   >
   >    - **函数和类的调用**：如果 `my.C` 中的代码依赖于 `precious.C` 中定义的函数或类，那么在链接时就需要将这两个目标文件链接在一起，以确保所有的引用都能被正确解析。
   >    - **共享数据**：如果两个文件之间有共享的数据结构或全局变量，链接过程也会确保这些数据在最终的可执行文件中是可访问的。

   可能需要显式地指定一些库。例如， 要访问数学库中定义的函数， 必须在命令行中加上-lm标记: 

   `CC usingmath.C -lm`

2. Linux编译和链接

   Linux系统中最常用的编译器是g++， 这是来自Free Software Foundation的 GNU C++编译器。 Linux的多数版本都包括该编译器， 但并不一定总会安装它。 g++编译器的工作方式很像标准UNIX 编译器。 例如， 下面的命令将生成可执行文件 a.out 

   `g++ spiffy.cxx`

   有些版本可能要求链接 C++库:

   `g++ spiffy.cxx -lg++`

   要编译多个源文件， 只需将它们全部放到命令行中即可:

   `g++ my.cxx precious.cxx`

   这将生成一个名为a.out的可执行文件和两个目标代码文件 my.o和precious.o。如果接下来修改了其中的某个源代码文件， 如 my.cxx, 则可以使用 my.cxx和precious.o 来重新编译 :
   `g++ my.cxx precious.o`

   GNU编译器可以在很多平台上使用 ， 包括基于Windows的 PC和在各种平台上 运行的UNIX系统 。

3. Windows命令行编译器

   要在WindowsPC上编译 C++程序， 最便宜的方法是下载一个在Windows 命令提示符模式(在这种模式下， 将打开一个类似于 MS-DOS 的窗口) 下运行的免费命令行编译器。Cygwin和MinGW 都包含编译器GNU C++， 且可免费下载; 它们使用的编译器名为g++。

   要使用 g++编译器， 首先需要打开一个命令提示符窗口。 启动程序Cygwin和MinGW时， 它们将自动打开一个命令提示符窗口。 要编译名为great.cpp的源代码文件， 请在提示符下输入如下命令:
   `g++ great.cpp`
    如果程序编译成功， 则得到的可执行文件名为a.exe。

4. Windows编译器

   Windows产品很多且修订频繁，无法对它们分别进行介绍。当前 ，最流行是Microsoft VisualC++2010。虽然设计和目标不同，但大多数基于Windows的 C++ 编译器都有一 些相同的功能。

   通常， 必须为程序创建一个项目 ， 并将组成程序的一个或 多个文件添加到该项目中。 每个厂商提供的 IDE(集成开发环境) 都包含用于创建项目的菜单选项(可能还有自动帮助)。 必须确定的非常重要的一点是， 需要创建的是什么类型的程序。 通常， 编译器提供了很多选择， 如Windows应用程序、 MFC Windows 应用程序 、 动态链接库、 ActiveX控件、 DOS 或字符模式的可执行文件、 静态库或控制台应用程序等 。 其中一些可能既有 32位版本， 又有64位版本。

   一般而言， 应选择包含字样 “控制台 “ 、”字符模式 ” 或
    “DOS可执行文件” 等选项。例如，在 Microsoft VisualC++ 2010中，应选择Win32 Console Application (控制台应用程序) 选项， 单击Application Settings(应用程序设置)， 并选择Empty Project (空项目)。 在C++ Builder中， 应从C++ Builder Projects (C++ Builder 项目) 中选择ConsoleApplication(控制台应用程序)。

   创建好项目后， 需要对程序进行编译和链接。IDE 通常提供了多个菜单项， 如Compile(编译)、Build (建立)、 Make(生成)、 BuildAll(全部建立)、Link(链接)、 Execute( 执行)、 Run( 运行) 和Debug(调试)， 不过同一个IDE中， 不一定包含所有这些选项。

   - Compile 通常意味着对当前打开的文件中的代码进行编译 。
   - Build和Make 通常意味着编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说， 如果项目包含 3 个文件， 而只有其中一个文件被修改， 则只重新编译该文件。
   - BuildAll 通常意味着重新编译所有的源代码文件。
   - Link 意味着(如前所述) 将编译后的源代码与所需的库代码组合起来。
   - Run或Execute 意味着运行程序。 通常， 如果您还没有执行前面的步骤， Run将在运行程序之前完成这些步骤。
   - Debug 意味着以步进方式执行程序。
   - 编译器可能让您选择要生成调试版还是发布版。 调试版包含额外的代码， 这会增大程序、 降低执行速度， 但可提供详细的调试信息。

   如果程序违反了语言规则， 编译器将生成错误消息， 指出存在问题的行。 有时， 真正的问题可能在标识行之前;有时， 一个错误可能引发一连串的错误消息。

   提示:改正错误时，应首先改正第一个错误。如果在标识为有错误的那一行上找不到错误，请查看前一行。

   需要注意的是， 程序能够通过某个编译器的编译并不意味着它是合法的C++程序;同样， 程序不能通 过某个编译器的编译也并不意味着它是非法的C++程序。与几年前相比，现在的编译器更严格地遵循了C++标准。 另外， 编译器通常提供了可用千控制严格程度的选项。

   提示:有时， 编译器在不完全地构建程序后将出现混乱， 它显示无法改正的、 无意义的错误消息。 在这种情况下， 可以选择 Build All, 重新编译整个程序， 以清除这些错误消息。 遗憾的是， 这种情况和那些更常见的情况(即错误消息只是看上去无意义， 实际上有意义)很难区分。

   通常，IDE允许在辅助窗口中运行程序。 程序执行完毕后， 有些IDE将关闭该窗口， 而有些IDE不关闭。 如果编译器关闭窗口， 将难以看到程序输出。 为查看输出， 必须在程序的最后加上 一些代码:

   ```cpp
     cin.get();// add this statement
     cin.get();// and maybe this, too
     return 0;
   }
   ```

   cin.get()语句读取下一次键击， 因此上述语句让程序等待， 直到按下了Enter键(在按下Enter键之前， 键击将不被发送给程序， 因此按其他键都不管用)。<u>如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。 例如， 如果要输入一个数字， 则需要输入该数字， 然后按 Enter 键。 程序将读取该数字， 但Enter键不被处理， 这样它将被第一个 cin.get()读取。</u>

   > **输入流的工作原理**
   >
   > 1. **输入缓冲区：**
   >
   >    当用户在控制台输入数据时，输入的内容会被存储在一个缓冲区中，直到用户按下 Enter 键。此时，整个输入（包括用户输入的字符和 Enter 键）会被送到程序的输入流中。
   >
   > 2. **读取输入：**
   >
   >    如果程序使用 `cin` 来读取输入（例如 `cin >> number;`），它会读取用户输入的数字，但不会读取 Enter 键。Enter 键仍然留在输入流中，等待后续的读取操作。
   >
   > **未处理的Enter键**
   >
   > 当程序读取完用户输入（例如一个数字）后，输入流中仍然存在一个 Enter 键的字符。这意味着如果程序完毕后IDE直接关闭窗口，在此之后如果只有一个输入读取操作（ `cin.get()`），程序用这个 `cin.get()`读取未处理的Enter键后程序完毕，窗口立即关闭。
   >
   > **示例**
   >
   > ```cpp
   > #include <iostream>
   > 
   > int main() {
   >     int number;
   >     std::cout << "请输入一个数字: ";
   >     std::cin >> number; // 用户输入数字并按下 Enter
   > 
   >     std::cout << "你输入的数字是: " << number << std::endl;
   > 
   >     // 处理遗留的 Enter 键
   >     std::cout << "按 Enter 键继续...";
   >     std::cin.get(); // 读取遗留的 Enter 键
   >     std::cin.get(); // 等待用户再次按下 Enter 键
   > 
   >     return 0;
   > }
   > ```

5. Macintosh上的C++

   当前， Apple随操作系统MacOSX提供了开发框架Xcode, 该框架是免费的， 但通常不会自动安装。要安装它， 可使用操作系统安装盘， 也可从Apple网站免费下载(但需要注意的是， 它超过4GB)。Xcode 不仅提供了支持多种语言的IDE，还自带了两个命令行编译器(g++和 clang)，可在UNXI 模式下运行它们。而要进入UNIX模式， 可通过实用程序Terminal。

# 第2章 开始学习C++

## 2.1 进入C++

 C++对大小写敏感， 也就是说区分大写字符和小写字符。例如，程序使用的是 cout，如果将其替换为 Cout 或 COUT, 程序将无法通过编译，并且编译器将指出使用了未知的标识符

事实上， C++能够使用 printf( )、 scanf( )和其他所有标准 C 输入和输出函数， 只需要包含常规 C 语言的 stdio.h文件。

### 2.1.1 main()函数

```cpp
int main() {
  statements
  return 0;
}
```

这几行代码构成了函数定义 (function definition)。 该定义由两部分组成: 第一行 int main( )叫函数头 (function heading)， 花括号({和})中包括的部分叫函数体。

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202411182154057.png)

函数头对函数与程序其他部分之间的接口进行了总结。

为理解源代码， 编译器需要知道一条语句何时结束， 另一条语句何时开始。 有些语言使用语句分隔符。 例如，FORTRAN通过<u>行尾</u>将语句分隔开来，Pascal使用分号分隔语句。在Pascal 中， 有些情况下可以省略分号， 例如END前的语句后面， 这种情况下， 实际上并没有将两条语句分开。不过C++与C一 样， 也使用终止符(terminator)， 而不是分隔符。 终止符是一 个分号， 它是语句的结束标记， 是语句的组成部分， 而不是语句之间的标记。

> "行尾"（end of line，EOL）是指一行代码的结束位置
>
> 在文本文件中，行尾通常由特定的字符或字符序列表示。常见的行尾字符包括：
>
> - **换行符（LF）**: 在 Unix 和 Linux 系统中，行尾通常由一个换行符（`\n`）表示。
> - **回车符（CR）**: 在旧的 Mac 系统中，行尾由一个回车符（`\r`）表示。
> - **回车换行符（CRLF）**: 在 Windows 系统中，行尾由回车符和换行符的组合（`\r\n`）表示。

通常，main()被启动代码调用，而启动代码是由编译器添加到程序中的， 是程序和操作系统之间的桥梁。 事实上，该函数头描述的是main()和操作系统之间的接口。

很多现有的程序都使用经典C函数头:

```c
main()// original C style
```

在C 语言中， 省略返回类型相当千说函数的类型为int 。 然而， C++逐步淘汰了这种用法。

也可以使用下面的变体:

```cpp
int main(void) // very explicit style
```

在括号中使用关键字void明确地指出， 函数不接受任何参数。 在C++中，让括号空着与在括号中使用void等效(在C中， 让括号空着意味着对是否接受参数保持沉默)。

ANSI/ISO C++标准对那些抱怨必须在main()函数最后包含一 条返回语句过于繁琐的人做出了让步。 如果编译器到达main()函数末尾时没有遇到返回语句， 则认为main()函数以如下语句结尾:

`return 0;`

这条隐含的返回语句只适用于main()函数，而不适用于其他函数。

### 2.1.3 C++预处理器和iostream文件

如果程序要使用C++输入或输出工具，请提供这样两行代码:

```cpp
#include <iostream>
using namespace std;
```

可使用其他代码替换第2 行， 这里使用这行代码旨在简化该程序

C++和C一样， 也使用一个预处理器， 该程序在进行主编译之前对源文件进行处理(第1章介绍过，有些C++实现使用翻译器程序将C++程序转换为C程序。 虽然翻译器也是一种预处理器，但这里不讨论这种预处理器，而只讨论这样的预处理器， 即它处理名称以#开头的编译指令)。 不必执行任何特殊的操作来调用该预处理器， 它会在编译程序时自动运行。

```cpp
#include <iostream> // a PREPROCESSOR direcive
```

该编译指令导致预处理器将iostream文件的内容添加到程序中。 这是一种典型的预处理器操作: 在源代码被编译之前，替换或添加文本。

# 附录

## 附录G 标准模板库方法和函数

### G.5 STL函数

STL算法库(由头文件algorithm和numeric支持)提供了大量基于迭代器的<u>非成员模板函数</u>。

> **非成员模板函数**：这些算法函数不是某个类的成员，而是独立的模板函数，可以接受不同类型的迭代器作为参数

正如第 16 章介绍的，选择的<u>模板参数名</u>指出了特定参数应模拟的概念。 例如，<u>Forwardlterator</u> 用于指出，参数至少应模拟正向迭代器的要求；<u>Predicate</u>用于指出，参数应是一个接受一个参数并返回bool 值的函数对象。

> 模板参数名：在定义这些算法时，使用了一些特定的名称来指示参数的要求。例如：
>
> - **ForwardIterator**：这个参数名表示传入的迭代器至少应该具备“正向迭代器”的特性，即可以从前向后遍历容器。
> - **Predicate**：这个参数名表示传入的函数对象应该接受一个参数并返回一个布尔值（`bool`），通常用于判断某个条件是否成立。

C++标准将算法分成4组：非修改式序列操作、修改式序列操作、排序和相关运算符以及数值操作(C++11 将数值操作从STL移到了numeric 库中， 但这不影响它们的用法)。 序列操作 (sequence operation)表明，函数将接受两个迭代器作为参数， 它们定义了要操作的区间或序列。 修改式 (mutating)意味着函数可以修改容器的内容。

#### G.5.1 非修改式序列操作

