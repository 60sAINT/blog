---
title: 一.C++基础语法入门
date: 2024-10-09
cover: assets/cpp.png
categories:
- [C++]
tags:
  - C++
---

# 1 C++初识

## 1.1 第一个C++程序

编写一个C++程序总共分为4个步骤

* 创建项目
* 创建文件
* 编写代码
* 运行程序

### 1.1.1 创建项目

Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开

### 1.1.2 创建文件

右键源文件，选择添加->新建项

给C++文件起个名称，然后点击添加即可。

### 1.1.3 编写代码

```c++
#include <iostream>
using namespace std;

int main() {
  cout << "hello World" << endl;
  return 0;
}
```

### 1.1.4 运行程序

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410091447921.png)

## 1.2 注释

**作用**：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码

**两种格式**

1. **单行注释**：`// 描述信息` 
   - 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==
2. **多行注释**： `/* 描述信息 */`
   - 通常放在一段代码的上方，==对该段代码做整体说明==

> 提示：编译器在编译代码时，会忽略注释的内容

## 1.3 变量

**作用**：给一段指定的内存空间起名，方便操作这段内存

> 假设一段内存中存放了数据10，请问有什么办法拿到这个数据呢？
>
> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410091520764.png)
>
> 方法一：记录内存地址编号，通常用十六进制的数字。有了这个编号，就能拿到10。问题来了：假设有100个数字，就要记100个地址编号，太麻烦了
>
> 方法二：给这段内存起一个名称比如a，它就能代表这段内存，能拿到10。非常方便，不用记地址编号。这个a就是变量，方便我们管理内存空间

**语法**：`数据类型 变量名 = 初始值;`

**示例：**

```C++
#include<iostream>
using namespace std;

int main() {
	//变量的定义
	//变量创建的语法：数据类型  变量名 = 初始值
	int a = 10;
	cout << "a = " << a << endl;
	return 0;
}
```

> 注意：C++在创建变量时，必须给变量一个初始值，否则会报错

## 1.4 常量

**作用**：用于记录程序中不可更改的数据

C++定义常量两种方式

1. **\#define** 宏常量： `#define 常量名 常量值`
   * ==通常在文件上方定义==，表示一个常量


2. **const**修饰的变量 `const 数据类型 常量名 = 常量值`
   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改

**示例：**

```C++
#include <iostream>
using namespace std;

// 1、#define宏常量
#define Day 7

int main() {
  // Day = 14; // 错误，Day是常量，一旦修改就会报错
  cout << "一周总共有：" << Day << "天" << endl;

  // 2、const修饰的变量
  const int month = 12;
  // month = 14; // 错误，const修饰的变量也称为常量
  cout << "一年总共有：" << month << "个月份" << endl;

  return 0;
}
```


## 1.5 关键字

**作用：**关键字是C++中预先保留的单词（标识符）

* **在定义变量或者常量时候，不要用关键字**

C++关键字如下：

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

`提示：在给变量或者常量起名称时候，不要用C++的关键字，否则会产生歧义。`

## 1.6 标识符命名规则

**作用**：C++规定给标识符（变量、常量）命名时，有一套自己的规则

* 标识符不能是关键字
* 标识符只能由字母、数字、下划线组成
* 第一个字符必须为字母或下划线
* 标识符中字母区分大小写

> 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读

# 2 数据类型

C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存

## 2.1 整型

**作用**：整型变量表示的是==整数类型==的数据

C++中能够表示整型的类型有以下几种方式，**区别在于所占内存空间不同**：

| **数据类型**        | **占用空间**                                    | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |

> ```cpp
> #include <iostream>
> using namespace std;
> 
> int main() {
>   // 1、短整型（-32768 ～ 32767）
>   short num1 = 32768;
>   // 2、整型
>   int num2 = 32768;
>   cout << "num1 = " << num1 << endl;
>   cout << "num2 = " << num2 << endl;
>   return 0;
> }
> ```
>
> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410091600205.png)

> 日常开发中，int最常用，如果没有特殊情况，基本上用int表示整数就足够了

## 2.2 sizeof关键字

**作用：**利用sizeof关键字可以==统计数据类型所占内存大小==（单位：字节）

**语法：** `sizeof( 数据类型 / 变量)`

**示例：**

```C++
int main() {
  short num1 = 10;
	cout << "short 类型所占内存空间为： " << sizeof(num1) << endl;// 2
	cout << "int 类型所占内存空间为： " << sizeof(int) << endl;// 4
	cout << "long 类型所占内存空间为： " << sizeof(long) << endl;// 8
  long long num2 = 10;
	cout << "long long 类型所占内存空间为： " << sizeof(num2) << endl;// 8
	return 0;
}
```

> **整型结论**：==short < int <= long <= long long==

## 2.3 实型（浮点型）

**作用**：用于==表示小数==

浮点型变量分为两种：

1. 单精度float
2. 双精度double

两者的**区别**在于表示的有效数字范围不同。

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

> C++中有效数字不单只统计小数点后的数，小数点前的整数部分也算有效数字。比如3.14有三位有效数字

**示例：**

```C++
int main() {
	float f1 = 3.1415926f;// 若不写f，编辑器会默认把这个小数当成双精度。如果用float接收它，编辑器会把3.14转换成单精度，多做一步转换
	double d1 = 3.1415926;
	cout << f1 << endl;
	cout << d1<< endl;
	cout << "float  sizeof = " << sizeof(f1) << endl;
	cout << "double sizeof = " << sizeof(d1) << endl;

	//科学计数法
	float f2 = 3e2; // 3 * 10 ^ 2 
	cout << "f2 = " << f2 << endl;
	float f3 = 3e-2;  // 3 * 10 ^ (-2)
	cout << "f3 = " << f3 << endl;

	return 0;
}
```

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410091646185.png)
>
> C++中默认情况下，输出一个小数**最多**显示6位有效数字。如果想查看更多的有效数字，需要额外做一些配置

## 2.4 字符型

**作用：**字符型变量用于显示单个字符

**语法：**`char ch = 'a';`

> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号

> 注意2：单引号内只能有一个字符，不可以是字符串

- C和C++中字符型变量只占用==1个字节==。
- 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元

示例：

```C++
int main() {
	// 1、字符型变量创建方式
	char ch = 'a';
	cout << ch << endl;
  
  // 2、字符型变量所占内存大小
	cout << sizeof(char) << endl;// 1

  // 3、字符型变量常见错误
	// ch2 = "b"; // 错误，不可以用双引号
	// ch2 = 'abcde'; // 错误，单引号内只能引用一个字符

  // 4、字符型变量对应ASCII编码
	cout << (int)ch << endl;// 查看字符a对应的ASCII码。打印97
	ch = 97;// 可以直接用ASCII给字符型变量赋值
	cout << ch << endl;// a

	return 0;
}
```

ASCII码表格：

| **ASCII**值 | **控制字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** | **ASCII**值 | **字符** |
| ----------- | ------------ | ----------- | -------- | ----------- | -------- | ----------- | -------- |
| 0           | NUT          | 32          | (space)  | 64          | @        | 96          | 、       |
| 1           | SOH          | 33          | !        | 65          | A        | 97          | a        |
| 2           | STX          | 34          | "        | 66          | B        | 98          | b        |
| 3           | ETX          | 35          | #        | 67          | C        | 99          | c        |
| 4           | EOT          | 36          | $        | 68          | D        | 100         | d        |
| 5           | ENQ          | 37          | %        | 69          | E        | 101         | e        |
| 6           | ACK          | 38          | &        | 70          | F        | 102         | f        |
| 7           | BEL          | 39          | ,        | 71          | G        | 103         | g        |
| 8           | BS           | 40          | (        | 72          | H        | 104         | h        |
| 9           | HT           | 41          | )        | 73          | I        | 105         | i        |
| 10          | LF           | 42          | *        | 74          | J        | 106         | j        |
| 11          | VT           | 43          | +        | 75          | K        | 107         | k        |
| 12          | FF           | 44          | ,        | 76          | L        | 108         | l        |
| 13          | CR           | 45          | -        | 77          | M        | 109         | m        |
| 14          | SO           | 46          | .        | 78          | N        | 110         | n        |
| 15          | SI           | 47          | /        | 79          | O        | 111         | o        |
| 16          | DLE          | 48          | 0        | 80          | P        | 112         | p        |
| 17          | DCI          | 49          | 1        | 81          | Q        | 113         | q        |
| 18          | DC2          | 50          | 2        | 82          | R        | 114         | r        |
| 19          | DC3          | 51          | 3        | 83          | S        | 115         | s        |
| 20          | DC4          | 52          | 4        | 84          | T        | 116         | t        |
| 21          | NAK          | 53          | 5        | 85          | U        | 117         | u        |
| 22          | SYN          | 54          | 6        | 86          | V        | 118         | v        |
| 23          | TB           | 55          | 7        | 87          | W        | 119         | w        |
| 24          | CAN          | 56          | 8        | 88          | X        | 120         | x        |
| 25          | EM           | 57          | 9        | 89          | Y        | 121         | y        |
| 26          | SUB          | 58          | :        | 90          | Z        | 122         | z        |
| 27          | ESC          | 59          | ;        | 91          | [        | 123         | {        |
| 28          | FS           | 60          | <        | 92          | /        | 124         | \|       |
| 29          | GS           | 61          | =        | 93          | ]        | 125         | }        |
| 30          | RS           | 62          | >        | 94          | ^        | 126         | `        |
| 31          | US           | 63          | ?        | 95          | _        | 127         | DEL      |

ASCII 码大致由以下**两部分组**成：

* ASCII 非打印控制字符： ASCII 表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII 打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

## 2.5 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段我们常用的转义字符有：` \n  \\  \t`

| **转义字符** | **含义**                                | **ASCII**码值（十进制） |
| ------------ | --------------------------------------- | ----------------------- |
| \a           | 警报                                    | 007                     |
| \b           | 退格(BS) ，将当前位置移到前一列         | 008                     |
| \f           | 换页(FF)，将当前位置移到下页开头        | 012                     |
| **\n**       | **换行(LF) ，将当前位置移到下一行开头** | **010**                 |
| \r           | 回车(CR) ，将当前位置移到本行开头       | 013                     |
| **\t**       | **水平制表(HT)  （跳到下一个TAB位置）** | **009**                 |
| \v           | 垂直制表(VT)                            | 011                     |
| **\\\\**     | **代表一个反斜线字符"\"**               | **092**                 |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F      | 3位16进制               |

示例：

```C++
int main() {
	
	cout << "\\" << endl;// 输出"\"会报错
  
  cout << "\tHello" << endl;// Hello前8个空格
	cout << "aaaa\tHello" << endl;// aaaa和Hello中间4个空格，空格有多长取决于\t前面占了几个字符。如果前面是aaa，则会拼接5个空格，一共加起来是8个字符
  cout << "aaaaaaaa\tHello" << endl;// aaaaaaaa和Hello中间8个空格
  // 一般来说水平制表符的最大用处就是在输出窗口有对齐效果，可以整齐输出数据
  
	cout << "\n" << endl;// C++中endl;作换行。在C语言用转义字符\n作换行

	return 0;
}
```

## 2.6 字符串型

**作用**：用于表示一串字符

**两种风格**

1. **C风格字符串**： `char 变量名[] = "字符串值"`

   示例：

   ```C++
   int main() {
   
   	char str1[] = "hello world";
   	cout << str1 << endl;
   
   	return 0;
   }
   ```

   > 注意：C风格的字符串要用双引号括起来

2. **C++风格字符串**：  `string  变量名 = "字符串值"`

   示例：

   ```C++
   #include <iostream>
   #include <string>
   using namespace std;
   
   int main() {
   
   	string str = "hello world";
   	cout << str << endl;
   
   	return 0;
   }
   ```

   > 注意：C++风格字符串，需要加入头文件==#include \<string>==

## 2.7 布尔类型 bool

**作用：**布尔数据类型代表真或假的值 

bool类型只有两个值：

* true  --- 真（本质是1）
* false --- 假（本质是0）

**bool类型占==1个字节==大小**

示例：

```C++
int main() {

	bool flag = true;
	cout << flag << endl; // 1

	flag = false;
	cout << flag << endl; // 0

	cout << "size of bool = " << sizeof(bool) << endl; // 1

	return 0;
}
```

## 2.8 数据的输入

**作用：用于从键盘获取数据**

**关键字：**cin

**语法：** `cin >> 变量 `

示例：

```C++
#include <iostream>
#include <string>
using namespace std;

int main(){

	//整型输入
	int a = 0;
	cout << "请输入整型变量：" << endl;
	cin >> a;
	cout << "整型变量a = " << a << endl;

	//浮点型输入
	float f = 3.14f;
	cout << "请输入浮点型变量：" << endl;
	cin >> f;
	cout << "浮点型变量f = " << f << endl;

	//字符型输入
	char ch = 0;
	cout << "请输入字符型变量：" << endl;
	cin >> ch;
	cout << "字符型变量ch = " << ch << endl;

	//字符串型输入
	string str;
	cout << "请输入字符串型变量：" << endl;
	cin >> str;
	cout << "字符串str = " << str << endl;

	//布尔类型输入
	bool flag = true;
	cout << "请输入布尔型变量："  << endl;
	cin >> flag;
  // 输入任何字符串或字符，都输出0。输入非0的任何数字，都输出1；输入0，输出0
	cout << "布尔类型flag = " << flag << endl;
  
	return EXIT_SUCCESS;
}
```

# 3 运算符

**作用：**用于执行代码的运算

本章我们主要讲解以下几类运算符：

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |

## 3.1 算术运算符

**作用**：用于处理四则运算 

算术运算符包括以下符号：

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前置递增   | a=2; b=++a; | a=3; b=3; |
| ++         | 后置递增   | a=2; b=a++; | a=3; b=2; |
| --         | 前置递减   | a=2; b=--a; | a=1; b=1; |
| --         | 后置递减   | a=2; b=a--; | a=1; b=2; |

**示例1：**

```C++
// 加减乘除
int main() {

	int a1 = 10;
	int b1 = 3;
	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
  
	cout << a1 / b1 << endl;// 输出3。两个整数相除结果依然是整数
	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl;// 0
  
	int a3 = 10;
	int b3 = 0;
	//cout << a3 / b3 << endl; // 报错，除数不可以为0

	//两个小数可以相除
	double d1 = 0.5;
	double d2 = 0.22;
	cout << d1 / d2 << endl;// 2.27273，运算的结果也可以是小数

	return 0;
}
```

> 总结：在除法运算中，除数不能为0

**示例2：**

```C++
//取模
int main() {

	int a1 = 10;
	int b1 = 3;
	cout << 10 % 3 << endl;// 1

	int a2 = 10;
	int b2 = 20;
	cout << a2 % b2 << endl;// 10

	int a3 = 10;
	int b3 = 0;
	//cout << a3 % b3 << endl; // 报错。取模运算时，除数也不能为0

	//两个小数不可以取模
	double d1 = 3.14;
	double d2 = 1.1;
	//cout << d1 % d2 << endl;// 报错

	return 0;
}
```

> 总结：只有整型变量可以进行取模运算

**示例3：**

```C++
//递增
int main() {

	//后置递增
	int a = 10;
	a++; //等价于a = a + 1
	cout << a << endl; // 11

	//前置递增
	int b = 10;
	++b;
	cout << b << endl; // 11

	//前置和后置的区别
	//前置递增先对变量进行++，再计算表达式
	int a2 = 10;
	int b2 = ++a2 * 10;
  cout << a2 << endl;// 11
	cout << b2 << endl;// 110
	//后置递增先计算表达式，后对变量进行++
	int a3 = 10;
	int b3 = a3++ * 10;
  cout << a3 << endl;// 11
	cout << b3 << endl;// 100

	return 0;
}
```

> 总结：前置递增先对变量进行++，再计算表达式，后置递增相反

## 3.2 赋值运算符

**作用：**用于将表达式的值赋给变量

赋值运算符包括以下几个符号：

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |

**示例：**

```C++
//赋值运算符
int main() {
  
	// =
	int a = 10;
	a = 100;
	cout << "a = " << a << endl;// 100

	// +=
	a = 10;
	a += 2; // a = a + 2;
	cout << "a = " << a << endl;// 12

	// -=
	a = 10;
	a -= 2; // a = a - 2
	cout << "a = " << a << endl;// 8

	// *=
	a = 10;
	a *= 2; // a = a * 2
	cout << "a = " << a << endl;// 20

	// /=
	a = 10;
	a /= 2;  // a = a / 2;
	cout << "a = " << a << endl;// 5

	// %=
	a = 10;
	a %= 2;  // a = a % 2;
	cout << "a = " << a << endl;// 0

	return 0;
}
```

## 3.3 比较运算符

**作用：**用于表达式的比较，并返回一个真值或假值

比较运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| \>         | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| \>=        | 大于等于 | 4 >= 1   | 1        |

示例：

```C++
int main() {

	int a = 10;
	int b = 20;

  // 不加小括号会报错。由于运算符有优先级的比较，想让比较运算符先做运算，就加小括号，先运算小括号内，再运算后面的输出换行
	cout << (a == b) << endl; // 0 
	cout << (a != b) << endl; // 1
	cout << (a > b) << endl; // 0
	cout << (a < b) << endl; // 1
	cout << (a >= b) << endl; // 0
	cout << (a <= b) << endl; // 1

	return 0;
}
```

> 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 

## 3.4 逻辑运算符

**作用：**用于根据表达式的值返回真值或假值

逻辑运算符有以下符号：

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；  如果a为真，则!a为假。             |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

**示例1：**逻辑非

```C++
//逻辑运算符  --- 非
int main() {

	int a = 10;

	cout << !a << endl; // 0
	cout << !!a << endl; // 1

	return 0;
}
```

> 总结： 真变假，假变真

**示例2：**逻辑与

```C++
//逻辑运算符  --- 与
int main() {

	int a = 10;
	int b = 10;
	cout << (a && b) << endl;// 1

	a = 10;
	b = 0;
	cout << (a && b) << endl;// 0 

	a = 0;
	b = 0;
	cout << (a && b) << endl;// 0

	return 0;
}

```

> 总结：逻辑==与==运算符总结： ==同真为真，其余为假==

**示例3：**逻辑或

```c++
//逻辑运算符  --- 或
int main() {

	int a = 10;
	int b = 10;
	cout << (a || b) << endl;// 1

	a = 10;
	b = 0;
	cout << (a || b) << endl;// 1 

	a = 0;
	b = 0;
	cout << (a || b) << endl;// 0

	return 0;
}
```

> 逻辑==或==运算符总结： ==同假为假，其余为真==

# 4 程序流程结构

C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码

## 4.1 选择结构

### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式

* 单行格式if语句

* 多行格式if语句

* 多条件的if语句


1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }`

   ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111430734.png)

   示例：

   ```C++
   #include <iostream>
   using namespace std;
   
   int main() {
     // 选择结构-单行if语句
     // 输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印
   
     int score = 0;
     cout << "请输入一个分数：" << endl;
     cin >> score;
     cout << "您输入的分数为： " << score << endl;
   
     // if语句
     // 注意事项，在if判断语句后面，不要加分号
     if (score > 600) {
       cout << "我考上了一本大学！！！" << endl;
     }
   
     return 0;
   }
   ```
   
   > 注意：if条件表达式后不要加分号

2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

   ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111430464.png)

   示例：

   ```cpp
   int main() {
     int score = 0;
     cout << "请输入考试分数：" << endl;
     cin >> score;
   
     if (score > 600) {
       cout << "我考上了一本大学" << endl;
     } else {
       cout << "我未考上一本大学" << endl;
     }
   
     return 0;
   }
   ```

3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

   !![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111431279.png)

   示例：

   ```cpp
   int main() {
     int score = 0;
     cout << "请输入考试分数：" << endl;
     cin >> score;
   
     if (score > 600) {
       cout << "我考上了一本大学" << endl;
     } else if (score > 500) {
       cout << "我考上了二本大学" << endl;
     } else if (score > 400) {
       cout << "我考上了三本大学" << endl;
     } else {
       cout << "我未考上本科" << endl;
     }
   
     return 0;
   }
   ```

**嵌套if语句**：在if语句中，可以嵌套使用if语句，达到更精确的条件判断

案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；
* 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。

**示例：**

```c++
int main() {
  int score = 0;
  cout << "请输入考试分数：" << endl;
  cin >> score;

  if (score > 600) {
    cout << "我考上了一本大学" << endl;
    if (score > 700) {
      cout << "我考上了北大" << endl;
    } else if (score > 650) {
      cout << "我考上了清华" << endl;
    } else {
      cout << "我考上了人大" << endl;
    }

  } else if (score > 500) {
    cout << "我考上了二本大学" << endl;
  } else if (score > 400) {
    cout << "我考上了三本大学" << endl;
  } else {
    cout << "我未考上本科" << endl;
  }

  return 0;
}
```

**练习案例：** 三只小猪称体重

有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111431908.jpg)

> 解题思路：
>
> 先判断A和B谁重
>
> 1. A重 -> 让A和C比较
>    - A重 -> 结果是A最重
>    - C重 -> 结果是C最重
> 2. B重 -> 让B和C比较
>    - B重 -> 结果是B最重
>    - C重 -> 结果是C最重

```cpp
int main() {
  // 1、创建三只小猪的体重变量
  int num1 = 0;
  int num2 = 0;
  int num3 = 0;

  // 2、让用户输入三只小猪的重量
  cout << "请输入小猪A的体重" << endl;
  cin >> num1;
  cout << "请输入小猪B的体重" << endl;
  cin >> num2;
  cout << "请输入小猪C的体重" << endl;
  cin >> num3;

  // 3、判断哪只最重
  if (num1 > num2) {
    if (num1 > num3) {
      cout << "小猪A最重" << endl;
    } else {
      cout << "小猪C最重" << endl;
    }
  } else {
    if (num2 > num3) {
      cout << "小猪B最重" << endl;
    } else {
      cout << "小猪C最重" << endl;
    }
  }

  return 0;
}
```

### 4.1.2 三目运算符

**作用：** 通过三目运算符实现简单的判断

**语法：**`表达式1 ? 表达式2 ：表达式3`

**解释：**

如果表达式1的值为真，执行表达式2，并返回表达式2的结果；

如果表达式1的值为假，执行表达式3，并返回表达式3的结果。

**示例：**

```C++
int main() {

  // 创建三个变量 a b c，将a和b做比较，将变量大的值赋值给变量c
	int a = 10;
	int b = 20;
	int c = 0;
	c = a > b ? a : b;
	cout << "c = " << c << endl;

	// C++中三目运算符返回的是变量,可以继续赋值
	(a > b ? a : b) = 100;

	cout << "a = " << a << endl;// 10
	cout << "b = " << b << endl;// 100
	cout << "c = " << c << endl;// 20

	return 0;
}
```

> 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰

### 4.1.3 switch语句

**作用：**执行多条件分支语句

**语法：**

```C++
switch (表达式) {
  case 结果1:
    执行语句;
    break;
  case 结果2:
    执行语句;
    break;
	...
	default:
    执行语句;
    break;
}
```

**示例：**

```C++
int main() {
  // 请给电影评分
  // 10 ~ 9   经典
  // 8 ~ 7    非常好
  // 6 ~ 5    一般
  // 5分以下   烂片

  int score = 0;
  cout << "请给电影打分" << endl;
  cin >> score;

  switch (score) {
    case 10:
    case 9:
      cout << "经典" << endl;
      break;
    case 8:
    case 7:
      cout << "非常好" << endl;
      break;
    case 6:
    case 5:
      cout << "一般" << endl;
      break;
    default:
      cout << "烂片" << endl;
      break;
  }
  // 如果去掉所有break;，输入10的话就会向下依次打印"经典"、"非常好"、"一般"、"烂片"，输入6的话就会依次向下打印"一般"、"烂片"

  return 0;
}
```

> 注意1：switch语句括号中表达式类型只能是整型或者字符型

> 注意2：case里如果没有break，那么程序会一直向下执行

> 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率比if执行速度高一些，缺点是switch不可以判断区间

## 4.2 循环结构

### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` while(循环条件){ 循环语句 }`

**解释：**==只要循环条件的结果为真，就执行循环语句==

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111746169.png)

**示例：**

```C++
int main() {

	int num = 0;
	while (num < 10) {
		cout << "num = " << num << endl;
		num++;
	}
	
	return 0;
}
```

> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环

**while循环练习案例：**==猜数字==

**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111746526.jpg)

```cpp
#include <ctime>
#include <iostream>
using namespace std;

int main() {
  // 添加随机数种子，利用当前系统时间生成随机数，若没有随机数种子则每次运行代码随机数都一样
  srand((unsigned int)time(NULL));  // time需要包含ctime系统时间头文件
  // 1、系统生成随机数
  int num = rand() % 100 + 1;  // rand() % 100意思是随机数对100取余，即生成0～99随机数

  // 2、玩家进行猜测
  int val = 0;  // 玩家输入的数据
  cin >> val;

  while (val != num) {
    // 3、判断玩家的猜测
    if (val > num) {
      cout << "猜测过大" << endl;
    } else {
      cout << "猜测过小" << endl;
    }
    cin >> val;
  }
  cout << "恭喜您猜对了" << endl;

  return 0;
  // 猜对：退出游戏
  // 猜错：提示猜的结果过大或过小，重新返回第2步
}
```

### 4.2.2 do...while循环语句

**作用：** 满足循环条件，执行循环语句

**语法：** `do{ 循环语句 } while(循环条件);`

**注意：**与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111747727.png)

**示例：**

```C++
int main() {

	int num = 0;

	do {
		cout << num << endl;
		num++;
	} while (num < 10);

	return 0;
}
```

> 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件

**练习案例：水仙花数**

**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身

例如：1^3 + 5^3+ 3^3 = 153

请利用do...while语句，求出所有3位数中的水仙花数

> 解题思路：
>
> 1. 循环遍历所有的三位数（100～999）
> 2. 在所有的三位数中找到水仙花数
>    1. 获取个位：num % 10，对数字取模于10可以获取个位
>    2. 获取十位：(num / 10) %10，先整除于10，得到两位数，再取模于10，得到十位
>    3. 获取百位：num / 100，直接整除于100，获取百位
>    4. 判断：个位^3 + 十位^3 + 百位^3 = 本身

```cpp
int main() {
  int num = 100;
  do {
    int unit = num % 10;
    int tens = num / 10 % 10;
    int hundreds = num / 100;
    if (unit * unit * unit + tens * tens * tens + hundreds * hundreds * hundreds == num) {
      cout << num << endl;
    }
    num++;
  } while (num < 1000);

  return 0;
}
```

### 4.2.3 for循环语句

**作用：**满足循环条件，执行循环语句

**语法：**` for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`

**示例：**

```C++
int main() {

	for (int i = 0; i < 10; i++) {
		cout << i << endl;
	}
  
	return 0;
}
```

**详解：**

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111747827.png)

> 注意：for循环中的表达式，要用分号进行分隔

> 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用

**练习案例：敲桌子**

案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111753044.gif)

> 解题思路：
>
> 1. 循环遍历1到100这些数字
>
> 2. 从这100个数字中找到特殊数字，改为“敲桌子”
>
>    特殊数字：
>
>    - 7的倍数，num % 7 = 0
>    - 个位有7，num % 10 = 7
>    - 十位有7，num / 10 = 7

```cpp
int main() {
  for (int i = 1; i <= 100; i++) {
    // 如果是7的倍数、个位有7、十位有7，打印敲桌子
    if (i % 7 == 0 || i % 10 == 7 || i / 10 == 7) {
      cout << "敲桌子" << endl;
    } else {  // 如果不是特殊数字，才打印数字
      cout << i << endl;
    }
  }
}
```

### 4.2.4 嵌套循环

**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111829354.png)

**示例：**

```C++
int main() {

	//外层循环执行1次，内层循环执行1轮
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			cout << "*" << " ";
		}
		cout << endl;
	}
  
	return 0;
}
```

**练习案例：**乘法口诀表

案例描述：利用嵌套循环，实现九九乘法表

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111831686.jpg)

```cpp
int main() {
  // 乘法口诀表
  for (int i = 1; i < 10; i++) {
    for (int j = 1; j <= i; j++) {
      cout << j << " x " << i << " = " << j * i << "\t";
    }
    cout << endl;
  }
}
```

## 4.3 跳转语句

### 4.3.1 break语句

**作用:** 用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是终止case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句

**示例1：**

```C++
int main() {
	//1、在switch 语句中使用break
	cout << "请选择您挑战副本的难度：" << endl;
	cout << "1、普通" << endl;
	cout << "2、中等" << endl;
	cout << "3、困难" << endl;

	int num = 0;
	cin >> num;
	switch (num) {
    case 1:
      cout << "您选择的是普通难度" << endl;
      break;
    case 2:
      cout << "您选择的是中等难度" << endl;
      break;
    case 3:
      cout << "您选择的是困难难度" << endl;
      break;
	}

	return 0;
}
```

**示例2：**

```C++
int main() {
	//2、在循环语句中用break
	for (int i = 0; i < 10; i++) {
		if (i == 5) {
			break; //跳出循环语句
		}
		cout << i << endl;
	}

	return 0;
}
```

**示例3：**

```C++
int main() {
	//在嵌套循环语句中使用break，退出内层循环
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 5) {
				break;
			}
			cout << "*" << " ";
		}
		cout << endl;
	}
	
	return 0;
}
```

### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

**示例：**

```C++
int main() {

	for (int i = 0; i < 100; i++) {
		if (i % 2 == 0) {
			continue;
		}
		cout << i << endl;
	}

	return 0;
}
```

> 注意：continue并没有使整个循环终止，而break会跳出循环

### 4.3.3 goto语句

**作用：**可以无条件跳转语句

**语法：** `goto 标记;`

**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置

**示例：**

```C++
int main() {

	cout << "1" << endl;

	goto FLAG;

	cout << "2" << endl;
	cout << "3" << endl;
	cout << "4" << endl;

	FLAG:
	cout << "5" << endl;

	return 0;
}
```

> 注意：在程序中不建议使用goto语句，以免造成程序流程混乱

# 5 数组

## 5.1 概述

所谓数组，就是一个集合，里面存放了相同类型的数据元素

**特点1：**数组中的每个==数据元素都是相同的数据类型==

**特点2：**数组是由==连续的内存==位置组成的

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410111905201.png)

## 5.2 一维数组

### 5.2.1 一维数组定义方式

一维数组定义的三种方式：

1. ` 数据类型  数组名[ 数组长度 ]; `
2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`
3. `数据类型  数组名[ ] = { 值1，值2 ...};`

示例

```C++
int main() {

	//定义方式1
	//数据类型 数组名[元素个数];
	int score[10];
	//利用下标赋值
	score[0] = 100;
	score[1] = 99;
	score[2] = 85;
	//利用下标输出
	cout << score[0] << endl;
	cout << score[1] << endl;
	cout << score[2] << endl;

	//第二种定义方式
	//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
	//如果{}内不足10个数据，剩余数据用0补全
	int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };
	//逐个输出
	//cout << score2[0] << endl;
	//cout << score2[1] << endl;
	//一个一个输出太麻烦，因此可以利用循环进行输出
	for (int i = 0; i < 10; i++) {
		cout << score2[i] << endl;
	}

	//定义方式3
	//数据类型 数组名[] =  {值1，值2 ，值3 ...};
	int score3[] = { 100,90,80,70,60,50,40,30,20,10 };
	for (int i = 0; i < 10; i++) {
		cout << score3[i] << endl;
	}
  
  int score4[]; // 报错：不允许使用不完整的类型。如果不能知道数组中有多少个数据元素，这个数组是不可以定义的。定义数组的时候，必须有初始长度

	return 0;
}
```

> 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名

> 总结2：数组中下标从0开始索引

### 5.2.2 一维数组数组名

一维数组名称的**用途**：

1. 可以统计整个数组在内存中的长度
2. 可以获取数组在内存中的首地址

**示例：**

```C++
#include <iostream>
using namespace std;

int main() {
  // 数组名用途
  // 1、可以统计整个数组在内存中的长度
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;// 40
  cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;// 4
  cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;// 10

  // 2、可以通过数组名获取到数组首地址
  cout << "数组首地址为： " << arr << endl;// 0x16fdfef40
  // &是取址符
  cout << "数组中第一个元素地址为： " << &arr[0] << endl;// 0x16fdfef40
  cout << "数组中第二个元素地址为： " << &arr[1] << endl;// 0x16fdfef44

  // arr = 100; 错误，数组名是常量，因此不可以赋值

  return 0;
}
```

> (int)arr、(int)&arr[0]、(int)&arr[1]报错： `cast from pointer to smaller type 'int' loses information` ，这是因为试图将指针类型转换为int类型，这可能导致信息丢失。尤其是在64位系统上，指针的大小通常是8字节，而int只有4字节
>
> 为了避免在64位系统上可能出现的信息丢失问题，应该使用 `uintptr_t` 或 `size_t` 类型来存储指针地址。
>
> ```cpp
> #include <cstdint> // 包含 uintptr_t
> cout << "数组首地址为： " << (uintptr_t)arr << endl;// 6171914048
> cout << "数组中第一个元素地址为： " << (uintptr_t)&arr[0] << endl;// 6171914048
> cout << "数组中第二个元素地址为： " << (uintptr_t)&arr[1] << endl;// 6171914052
> ```
>
> - `uintptr_t` 不是用来将十六进制数转换为十进制数的，而是一个无符号整数类型，足够大以存储指针，适用于指针与整数之间的转换。
> - 在输出指针地址时，使用 `uintptr_t` 可以确保在不同平台上都能正确处理指针大小。它的大小与平台相关，通常在 32 位系统上是 32 位，在 64 位系统上是 64 位。
> - 可以安全地将指针转换为 `uintptr_t` 类型，然后再转换回指针，而不会丢失信息。

注意：数组名是常量，不可以赋值

总结1：直接打印数组名，可以查看数组所占内存的首地址

总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小

**练习案例1**：五只小猪称体重

**案例描述：**

在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};

找出并打印最重的小猪体重。

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410121030406.png)

```cpp
int main() {
  // 1、创建5只小猪体重的数组
  int arr[5] = {300, 350, 200, 400, 250};
  // 2、从数组中找到最大值
  int max = 0;  // 先认定一个最大值为0
  for (int i = 0; i < 5; i++) {
    if (arr[i] > max) {
      // 如果访问的数组中的元素比我认定的最大值还要大，更新最大值
      max = arr[i];
    }
  }
  cout << "最重的小猪体重为：" << max << endl;
  // 3、打印最大值
  return 0;
}
```

**练习案例2：**数组元素逆置

**案例描述：**请声明一个5个元素的数组，并且将元素逆置.

(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);

> 分析：
>
> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410121119103.jpg)

```cpp
int main() {
  // 1、创建数组
  int arr[5] = {1, 3, 2, 5, 4};

  // 2、实现逆置
  // 2.1 记录起始下标位置
  // 2.2 记录结束下标位置
  // 2.3 起始下标与结束下标的元素呼唤
  // 2.4 起始位置++，结束位置--
  // 2.5 循环执行2.1操作，直到起始位置 >= 结束位置
  int start = 0;
  int end = sizeof(arr) / sizeof(arr[0]) - 1;
  while (start < end) {
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
  }

  // 3、打印逆置后的数组
  cout << "数组元素逆置后：" << endl;
  for (int i = 0; i < 5; i++) {
    cout << arr[i] << endl;
  }
}
```

### 5.2.3 冒泡排序

**作用：** 最常用的排序算法，对数组内元素进行排序

1. 比较相邻的元素，保证大的放后面。
2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值冒泡到最后面。
3. 重复以上的步骤，每次比较次数-1，直到不需要比较

![1541905327273](assets/1541905327273.png)

**示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410121800895.jpg)

```C++
int main() {
  int arr[9] = {4, 2, 8, 0, 5, 7, 1, 3, 9};

  // 外层循环执行一次代表元素从前到后排序一轮，排序轮数为元素个数-1
  for (int i = 0; i < 9 - 1; i++) {
    // 内层循环对比相邻元素，一轮的对比次数=元素个数-当前轮数-1
    for (int j = 0; j < 9 - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }

  cout << "排序后：" << endl;
  for (int i = 0; i < 9; i++) {
    cout << arr[i] << endl;
  }
}
```

## 5.3 二维数组

二维数组就是在一维数组上，多加一个维度。

![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410121800519.jpg)

### 5.3.1 二维数组定义方式

二维数组定义的四种方式：

1. ` 数据类型  数组名[ 行数 ][ 列数 ]; `
2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`
4. ` 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`

> 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==

示例：

```C++
int main() {

	//方式1  
	//数组类型 数组名 [行数][列数]
	int arr[2][3];
	arr[0][0] = 1;
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 3; j++) {
			cout << arr[i][j] << " ";
		}
		cout << endl;
	}

	//方式2 
	//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
	int arr2[2][3] = {
		{1,2,3},
		{4,5,6}
	};
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      cout << arr2[i][j] << " ";
    }
    cout << endl;
  }

	//方式3
	//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr3[2][3] = { 1,2,3,4,5,6 }; 

	//方式4 
	//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
	int arr4[][3] = { 1,2,3,4,5,6 };
  
  int arr5[][] = { 1, 2, 3, 4, 5, 6};
  // 报错：数组不能包含此类型的元素。不知道几行几列，可以是1行6列、6行1列、2行3列、3行2列，有很多种排列组合方式，没法计算
  int arr6[2][] = {1, 2, 3, 4, 5, 6};
  /* 报错：1.数组不能包含此类型的元素
  2.初始值设定项值太多<error-type> [2]{(<error-type>)<error-constant>, (<error-type>)<error-constant>}。
  */

	return 0;
}
```

> 在定义多维数组时，必须指定所有维度的大小，除了第一维（行数）。
>
> ```cpp
> int arr[2][3]; // 正确，定义了一个有 2 行 3 列的二维数组
> int arr[][3] = {{1, 2, 3}, {4, 5, 6}}; // 正确，行数可以省略，列数必须指定
> int arr6[2][] = {1, 2, 3, 4, 5, 6}; // 错误，列数未指定
> ```
>
> **为什么行数可以省略而列数不可以**
>
> - **内存布局**：在内存中，数组是以连续的方式存储的。为了计算每个元素的地址，编译器需要知道每一行的列数，以便在访问时能够正确地跳转到下一行的起始位置。
> - **灵活性**：允许省略行数使得数组的定义更加灵活，尤其是在==处理动态数据==时。你可以根据需要==定义不同数量的行，而列数通常是固定的==。

总结：在定义二维数组时，如果初始化了数据，可以省略行数

### 5.3.2 二维数组数组名

* 查看二维数组所占内存空间
* 获取二维数组首地址

**示例：**

```C++
int main() {

	//二维数组数组名
	int arr[2][3] = {
		{1,2,3},
		{4,5,6}
	};

	cout << "二维数组大小： " << sizeof(arr) << endl;// 24。2行3列一共6个数据，每个整型数据占用的内存空间是4字节
	cout << "二维数组一行大小： " << sizeof(arr[0]) << endl;
	cout << "二维数组元素大小： " << sizeof(arr[0][0]) << endl;
	cout << "二维数组行数： " << sizeof(arr) / sizeof(arr[0]) << endl;
	cout << "二维数组列数： " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;

	//地址
	cout << "二维数组首地址：" << arr << endl;
	cout << "二维数组第一行地址：" << arr[0] << endl;// 首地址和第一行地址一样
	cout << "二维数组第二行地址：" << arr[1] << endl;// 第二行和第一行差12
	cout << "二维数组第一个元素地址：" << &arr[0][0] << endl;// 第一个元素地址和首地址、第一行地址一样
	cout << "二维数组第二个元素地址：" << &arr[0][1] << endl;// 第二个元素地址和第一个元素地址差4

	return 0;
}
```

> 总结1：二维数组名就是这个数组的首地址

> 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小

## **5.3.3 二维数组应用案例**

**考试成绩统计：**

案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**

|      | 语文 | 数学 | 英语 |
| ---- | ---- | ---- | ---- |
| 张三 | 100  | 100  | 100  |
| 李四 | 90   | 50   | 100  |
| 王五 | 60   | 70   | 80   |

> 分析：
>
> 1. 创建二维数组，3行3列
> 2. 统计考试成绩，让每行的3列相加，统计出总和

**参考答案：**

```C++
#include <iostream>
#include <string>
using namespace std;

int main() {

	int scores[3][3] = {
		{100,100,100},
		{90,50,100},
		{60,70,80},
	};

	string names[3] = { "张三","李四","王五" };

	for (int i = 0; i < 3; i++) {
		int sum = 0;
		for (int j = 0; j < 3; j++) {
			sum += scores[i][j];
		}
		cout << names[i] << "同学总成绩为： " << sum << endl;
	}

	return 0;
}
```

# 6 函数

## 6.1 概述

**作用：**将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

## 6.2 函数的定义

函数的定义一般主要有5个步骤：

1、返回值类型 

2、函数名

3、参数列表

4、函数体语句 

5、return 表达式

**语法：** 

```C++
返回值类型 函数名 （参数列表） {

       函数体语句

       return表达式

}
```

* 返回值类型 ：一个函数可以返回一个值。在函数定义中
* 函数名：给函数起个名称
* 参数列表：使用该函数时，传入的数据
* 函数体语句：花括号内的代码，函数内需要执行的语句
* return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据

**示例：**定义一个加法函数，实现两个数相加

```C++
//函数定义
int add(int num1, int num2) {
	int sum = num1 + num2;
	return sum;
}
```

## 6.3 函数的调用

**功能：**使用定义好的函数

**语法：**` 函数名（参数）`

**示例：**

```C++
//函数定义
int add(int num1, int num2) {
  // 函数定义中的时候，num1和num2并没有真实数据，只是一个形式上的参数，简称形参
	int sum = num1 + num2;
	return sum;
}

int main() {

	int a = 10;
	int b = 10;
	// main函数中调用add函数
	int sum = add(a, b);// 调用时的a，b称为实际参数，简称实参。当调用函数的时候，实参的值会传递给形参
	cout << "sum = " << sum << endl;

	a = 100;
	b = 100;
	sum = add(a, b);
	cout << "sum = " << sum << endl;

	return 0;
}
```

> 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参

## 6.4 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生任何改变，并不会影响实参==

**示例：**

```C++
void swap(int num1, int num2) {
	cout << "交换前：" << endl;
	cout << "num1 = " << num1 << endl;// 10
	cout << "num2 = " << num2 << endl;// 20

	int temp = num1;
	num1 = num2;
	num2 = temp;

	cout << "交换后：" << endl;
	cout << "num1 = " << num1 << endl;// 20
	cout << "num2 = " << num2 << endl;// 10

	// return; 当函数声明时候，不需要返回值，可以不写return。也可以写return;
}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	cout << "mian中的 a = " << a << endl;// 10
	cout << "mian中的 b = " << b << endl;// 20

	return 0;
}
```

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410121830156.png)
>
> 1. 创建数据a，在内存上开辟4个字节给变量a
> 2. 在内存上创建一个变量b=20
> 3. 把a和b调入函数体的时候，num1和num2也是要分配空间的，跟a和b不是一个东西
> 4. 在内存上再分配2块内存，一个是num1，还有一个是num2。由于是值传递，会把a的数据给num1，b的数据给num2
> 5. 下面的代码中，int temp = num1;，temp也是一个变量，也要分配一块临时的内存空间 ，这个临时的空间等于num1
> 6. num2的值赋值给了num1
> 7. temp的值给了num2，temp值没有发生改变，还是10。
> 8. 当 `swap` 函数返回时，所有在该函数中定义的局部变量（`num1`、`num2`、`temp`）都会被销毁，释放它们占用的内存。
> 9. 在程序执行期间，a和b从头到尾都没发生改变

总结： 值传递时，形参是修饰不了实参的

## **6.5 函数的常见样式**

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

**示例：**

```C++
//函数常见样式
//1、 无参无返
void test01() {
	//void a = 10; //无类型不可以创建变量,原因无法分配内存
	cout << "this is test01" << endl;
}

//2、 有参无返
void test02(int a) {
	cout << "this is test02 a = " << a << endl;
}

//3、无参有返
int test03() {
	cout << "this is test03" << endl;
	return 10;
}

//4、有参有返
int test04(int a) {
	cout << "this is test04 a = " << a << endl;
	return a;
}

int main() {
  // 无参无返函数调用
  test01();// "this is test01"
  
  // 有参无返函数调用
  test02(100);// this is test02 a = 100
  
  // 无参有返函数调用
  int num1 = test03();// this is test03
  cout << "num1 = " << num1 << ednl;// num1 = 10
  
  // 有参有返函数调用
  int num2 = test04(10000);// this is test04 a = 10000
  cout << "num2 = " << num2 << endl;// num2 = 10000
  
  return 0;
}
```

## 6.6 函数的声明

**作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

*  函数的**声明可以多次**，但是函数的**定义只能有一次**

**示例：**

```C++
// 提前告诉编译器函数的存在，可以利用函数的声明
// 声明可以多次，定义只能一次
// 声明
int max(int a, int b);
int max(int a, int b);
// 定义
int max(int a, int b) {
	return a > b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout << max(a, b) << endl;// 20

	return 0;
}
```

> - 如果把main函数写在最前面，把max函数的声明和定义写到后边，运行会报错：`"max": 找不到标识符`，双击报错信息定位到main函数里的调用max语句。因为代码是一行一行执行的，所以执行到main中调用max那行的时候，看不到max在哪，往下执行到max定义语句的时候才能找到它，发现得比较晚
> - 只要把max函数的声明放在main前面，不管函数的定义放在main前还是main后，都不会报错

## 6.7 函数的分文件编写

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤

1. 创建后缀名为.h的头文件  
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

**示例：**

swap.h文件：

```C++
#include<iostream>
using namespace std;

//实现两个数字交换的函数声明
void swap(int a, int b);
```

swap.cpp文件：

```C++
#include "swap.h"

// 函数的定义
void swap(int a, int b) {
	int temp = a;
	a = b;
	b = temp;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
}
```

main.cpp文件：

```C++
#include "swap.h"
int main() {

	int a = 100;
	int b = 200;
	swap(a, b);

	return 0;
}
```

# 7 指针

## 7.1 指针的基本概念

**指针的作用：** 可以通过指针间接访问内存

* 内存编号是从0开始记录的，一般用十六进制数字表示
* 可以利用指针变量保存地址

  > ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410131425245.png)
  >
  > 如果知道了地址编号是多少，也可以拿到10这个数据。可以再创建一个变量，而这个变量中保存的数据是0x0000，即数据10的地址。这个变量就可以称为指针变量，通常写成p来代表一个指针

## 7.2 指针变量的定义和使用

指针变量定义语法： `数据类型 * 变量名；`

**示例：**

```C++
int main() {

	//1、定义指针
	int a = 10; //定义整型变量a
	//指针定义的语法： 数据类型 * 指针变量名;
	int* p;
	//指针变量赋值
	p = &a; //让指针记录变量a的地址
	cout << &a << endl; //打印数据a的地址
	cout << p << endl;  //打印指针变量p

	//2、使用指针
	//可以通过解引用的方式来找到指针指向的内存中的数据
  //指针前加 * 代表解引用
	cout << "*p = " << *p << endl;
  *p = 1000;// 通过指针可以修改指向的数据，也可以访问指向的数据
  cout << "a = " << a << endl;// 1000
  cout << "*p = " << *p << endl;// 1000

	return 0;
}
```

指针变量和普通变量的区别

* 普通变量存放的是数据,指针变量存放的是地址
* 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用

> 总结1： 我们可以通过 & 符号 获取变量的地址

> 总结2：利用指针可以记录地址

> 总结3：对指针变量解引用，可以操作指针指向的内存

## 7.3 指针所占内存空间

提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？

**示例：**

```C++
int main() {
  int a = 10;

  int* p = &a;  // 指针指向数据a的地址

  cout << *p << endl;  // 10。* 解引用
  cout << sizeof(p) << endl;// 8
  cout << sizeof(char *) << endl;// 8
  cout << sizeof(float *) << endl;// 8
  cout << sizeof(double *) << endl;// 8

  return 0;
}
```

在 C++ 中，指针的大小取决于系统的架构（32 位或 64 位）。

- **32 位系统**：指针类型的变量通常占用 **4 个字节**（32 位）。
- **64 位系统**：指针类型的变量通常占用 **8 个字节**（64 位）。

> 指针的大小是由地址空间的大小决定的。在 32 位系统中，地址空间限制在 2^32（即 4 GB），因此需要 4 个字节来表示一个地址。而在 64 位系统中，地址空间可以达到 2^64（即非常大的空间），因此需要 8 个字节来表示一个地址

## 7.4 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可以访问的

**示例1：空指针**

```C++
int main() {

	//指针变量p指向内存地址编号为0的空间
	int* p = NULL;

	//访问空指针报错 
	//内存编号0 ~255为系统占用内存，不允许用户访问
  *p = 100;
	cout << *p << endl;
  /*
  以上两行代码报错皆为：
  发生异常: Exception
  EXC_BAD_ACCESS (code=1, address=0x0)
  */

	return 0;
}
```

**野指针**：指针变量指向非法的内存空间

**示例2：野指针**

```C++
int main() {
  // 指针变量p指向内存地址编号为0x1100的空间
  int* p = (int*)0x1100;

  /* 访问野指针报错：
  发生异常: Exception
  EXC_BAD_ACCESS (code=1, address=0x1100)
  */
  cout << *p << endl;

  return 0;
}
```

> 0x1100是随便拿一指针在内存中指向的编号，但并没有申请这块地址，所以没有访问权限、没有权利操纵这块内存

总结：空指针和野指针都不是我们申请的空间，因此不要访问。

## 7.5 const修饰指针

const修饰指针有三种情况

1. const修饰指针   --- 常量指针

   > ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410131729050.png)
2. const修饰常量   --- 指针常量

   > ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410131731965.png)
3. const既修饰指针，又修饰常量

   > ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410131732600.png)

**示例：**


```c++
int main() {

	int a = 10;
	int b = 10;

	// 1、const修饰指针，指针指向可以改，指针指向的值不可以更改
	const int* p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  //报错
	

	// 2、const修饰常量，指针指向不可以改，指针指向的值可以更改
	int* const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

  // 3、const修饰指针和常量
	const int* const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误

	return 0;
}
```

> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量

## 7.6 指针和数组

**作用：**利用指针访问数组中元素

**示例：**

```C++
int main() {

	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;  //指向数组的指针
  // 数组arr的元素类型和指针p指向的数据类型换成double，也是一样的效果

	cout << "第一个元素： " << arr[0] << endl;
	cout << "指针访问第一个元素： " << *p << endl;

	for (int i = 0; i < 10; i++) {
		//利用指针遍历数组
		cout << *p << endl;
		p++;// 让指针往后移指向的数据的类型所占字节。这里往后移4个字节
	}

	return 0;
}
```

## 7.7 指针和函数

**作用：**利用指针作函数参数，可以修改实参的值

**示例：**

```C++
//值传递
void swap1(int a ,int b) {
	int temp = a;
	a = b; 
	b = temp;
}

//地址传递
void swap2(int* p1, int* p2) {
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main() {

	int a = 10;
	int b = 20;
  
	swap1(a, b); // 值传递不会改变实参
	cout << "a = " << a << endl;// 10
	cout << "b = " << b << endl;// 20

	swap2(&a, &b); //地址传递会改变实参
	cout << "a = " << a << endl;// 20
	cout << "b = " << b << endl;// 10

	return 0;
}
```

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410131808376.png)
>
> 1. 内存条一开始分配了4个字节空间，放变量int a = 10
> 2. 创建变量b = 20
> 3. 程序跳转到swap02函数体，指针p1和p2要去接收a和b的地址。这时候会创建出来一个指针p1 = 变量a的地址0x0011，p2 = 变量b的地址0x0022
> 4. 创建变量temp，这个临时变量也要分配内存空间，等于*p1，相当于解引用，找0x0011这块内存指向的数据10
> 5. *p2是p2这个指针指向0x0022这块内存的值，相当于把20赋值给了p1指向的内存，即a
> 6. temp的值10给p2指向的内存

总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递

## 7.8 指针、数组、函数

**案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序

例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };

**示例：**

```c++
//冒泡排序函数
void bubbleSort(int* arr, int len) {// int* arr 也可以写为int arr[]
	for (int i = 0; i < len - 1; i++) {
		for (int j = 0; j < len - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//打印数组函数
void printArray(int arr[], int len) {
	for (int i = 0; i < len; i++) {
		cout << arr[i] << endl;
	}
}

int main() {

	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int len = sizeof(arr) / sizeof(int);

	bubbleSort(arr, len);
	printArray(arr, len);
  // 一般来说给一个数组做一些操作的时候，还会传入数组有多长

	return 0;
}
```

> 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针

# 8 结构体

## 8.1 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型

## 8.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 }；`

通过结构体创建变量的方式有三种：

1. struct 结构体名 变量名
2. struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
3. 定义结构体时顺便创建变量

**示例：**

```C++
#include <iostream>
#include <string>
using namespace std;

// 1、创建学生数据类型：学生包括姓名，年龄，分数
// 自定义数据类型：一些类型集合组成的一个类型
// 结构体定义的时候，struct关键字不可以省略
struct Student {
  // 成员列表
  string name;
  int age;
  int score;
};

// 2、通过学生类型创建具体学生
// 结构体变量在创建的时候，struct关键字可以省略
int main() {
  // 2.1 struct Student s1
  struct Student s1;// 可以不写struct：Student s1;
  s1.name = "张三";
  s1.age = 18;
  s1.score = 100;
  cout << "姓名：" << s1.name << " 年龄：" << s1.age << " 分数：" << s1.score << endl;

  // 2.2 struct Student s2 = { ... }
  struct Student s2 = {"李四", 19, 80};
  cout << "姓名：" << s2.name << " 年龄：" << s2.age << " 分数：" << s2.score << endl;
}
```

```cpp
#include <iostream>
#include <string>
using namespace std;

struct Student {
  string name;
  int age;
  int score;
} s3;

int main () {
  // 2.3 在定义结构体时顺便创建结构体变量
  s3.name = "王五";
  s3.age = 20;
  s3.score = 60;
  cout << "姓名：" << s3.name << " 年龄：" << s3.age << " 分数：" << s3.score << endl;
  
  // 仍然可以继续用Student这个结构体创建其他结构变量
}
```

> 总结1：定义结构体时的关键字是struct，不可省略

> 总结2：创建结构体变量时，关键字struct可以省略

> 总结3：结构体变量利用操作符 ''.''  访问成员

## 8.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**` struct 结构体名 数组名[元素个数] = {  {} , {} , ... {} }`

**示例：**

```C++
// 1、定义结构体
struct Student {
  // 成员列表
  string name;  // 姓名
  int age;      // 年龄
  int score;    // 分数
};

int main() {
  // 2、创建结构体数组
  // 结构体数组在创建的时候，struct关键字可以省略
  struct Student arr[3] = {
      {"张三", 18, 80},
      {"李四", 19, 60},
      {"王五", 20, 70}};
  
  // 3、给结构体数组中的元素赋值
  arr[2].name = "赵六";
  arr[2].age = 80;
  arr[2].score = 60;

  // 4、遍历结构体数组
  for (int i = 0; i < 3; i++) {
    cout << "姓名：" << arr[i].name << " 年龄：" << arr[i].age << " 分数：" << arr[i].score << endl;
  }

  return 0;
}
```

## 8.4 结构体指针

**作用：**通过指针访问结构体中的成员

* 利用操作符 `-> `可以通过结构体指针访问结构体属性

**示例：**

```C++
// 结构体定义
struct Student {
  // 成员列表
  string name;  // 姓名
  int age;      // 年龄
  int score;    // 分数
};

int main() {
  struct Student stu = {
      "张三",
      18,
      100,
  };

  struct Student* p = &stu;

  p->score = 80;  // 指针通过 -> 操作符可以访问成员

  cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;

  return 0;
}
```

> 总结：结构体指针可以通过 -> 操作符 来访问结构体中的成员

## 8.5 结构体嵌套结构体

**作用：** 结构体中的成员可以是另一个结构体

**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

**示例：**

```C++
//学生结构体定义
struct Student {
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//教师结构体定义
struct Teacher {
  //成员列表
	int id; //职工编号
	string name;  //教师姓名
	int age;   //教师年龄
	struct Student stu; //子结构体 学生
};

int main() {

	struct Teacher t1;
	t1.id = 10000;
	t1.name = "老王";
	t1.age = 40;

	t1.stu.name = "张三";
	t1.stu.age = 18;
	t1.stu.score = 100;

	cout << "教师 职工编号： " << t1.id << " 姓名： " << t1.name << " 年龄： " << t1.age << endl;
	
	cout << "辅导学员 姓名： " << t1.stu.name << " 年龄：" << t1.stu.age << " 考试分数： " << t1.stu.score << endl;

	return 0;
}
```

**总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题

## 8.6 结构体做函数参数 

**作用：**将结构体作为参数向函数中传递

传递方式有两种：

* 值传递
* 地址传递

**示例：**

```C++
//学生结构体定义
struct Student {
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//值传递
void printStudent(Student stu) {
	stu.age = 28;
	cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;// age：28
}

//地址传递
void printStudent2(Student* stu) {
	stu->age = 28;
	cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;// age：28
}

int main() {

	Student stu = { "张三",18,100};
  
	//值传递
	printStudent(stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;// age：18

	cout << endl;

	//地址传递
	printStudent2(&stu);
	cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;// age：28

	return 0;
}
```

> 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递

## 8.7 结构体中 const使用场景

**作用：**用const来防止误操作

**示例：**

```C++
//学生结构体定义
struct Student
{
	//成员列表
	string name;  //姓名
	int age;      //年龄
	int score;    //分数
};

//const使用场景
//加const防止函数体中的误操作
void printStudent(const Student* stu) {
	//stu->age = 100; // 加入const之后，一旦有修改的操作就会报错
	cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;
}

int main() {

	Student stu = { "张三",18,100 };

	printStudent(&stu);

	return 0;
}
```

> 在函数 `printStudent` 中，参数 `const student* stu` 表示 `stu` 是一个指向 `student` 结构体的指针，并且指向的 `student` 对象的内容是不可修改的。这意味着不能通过 `stu` 来修改 `student` 结构体的成员变量（如 `age`、`name` 和 `score`）
>
> 尽管 `stu` 指向的 `student` 对象的内容不能被修改，但指针 `stu` 本身是可以改变的。也就是说，你可以让 `stu` 指向另一个 `student` 对象。以下是一个示例：
>
> ```cpp
> #include <iostream>
> #include <cstring>
> using namespace std;
> 
> struct Student {
>     char name[50];
>     int age;
>     float score;
> };
> 
> int main() {
>     Student stu1 = {"Alice", 20, 90.5};
>     Student stu2 = {"Bob", 22, 85.0};
> 
>     const Student* ptr = &stu1; // ptr 指向 stu1
>     ptr = &stu2; // ptr 现在指向 stu2，这行是合法的
> 
>     return 0;
> }
> ```
>
> - `const student* stu` 表示 `stu` 指向的 `student` 对象的内容不可修改
> - 但是，指针 `stu` 本身是可以改变的，你可以让它指向另一个 `student` 对象

## 8.8 结构体案例

### 8.8.1 案例1

**案例描述：**

学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下

设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员。学生的成员有姓名、考试分数

创建数组存放3名老师，通过函数给每个老师及所带的学生赋值

最终打印出老师数据以及老师所带的学生数据。

> ![](https://cdn.jsdelivr.net/gh/60sAINT/images@latest/202410140935254.png)

**示例：**

```C++
#include <iostream>
using namespace std;
#include <string>
#include <ctime>

struct Student {
	string name;
	int score;
};
struct Teacher {
	string name;
	Student sArray[5];
};

void allocateSpace(Teacher tArray[] , int len) {
	string tName = "教师";
	string sName = "学生";
	string nameSeed = "ABCDE";
	for (int i = 0; i < len; i++)
	{
		tArray[i].name = tName + nameSeed[i];
		
		for (int j = 0; j < 5; j++) {
			tArray[i].sArray[j].name = sName + nameSeed[j];
			tArray[i].sArray[j].score = rand() % 61 + 40;
		}
	}
}

void printTeachers(Teacher tArray[], int len) {
	for (int i = 0; i < len; i++) {
		cout << tArray[i].name << endl;
		for (int j = 0; j < 5; j++) {
			cout << "\t姓名：" << tArray[i].sArray[j].name << " 分数：" << tArray[i].sArray[j].score << endl;
		}
	}
}

int main() {

	srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>

	Teacher tArray[3]; // 1、创建数组存放3名老师

	int len = sizeof(tArray) / sizeof(Teacher);
	allocateSpace(tArray, len); // 2、通过函数给每个老师及所带的学生赋值
	printTeachers(tArray, len); // 3、打印出老师数据以及老师所带的学生数据

	return 0;
}
```

### 8.8.2 案例2

**案例描述：**

设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。

通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。

五名英雄信息如下：

```C++
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
```

**示例：**

```C++
//英雄结构体
struct Hero {
	string name;
	int age;
	string sex;
};
//冒泡排序
void bubbleSort(Hero arr[] , int len) {
	for (int i = 0; i < len - 1; i++) {
		for (int j = 0; j < len - 1 - i; j++) {
			if (arr[j].age > arr[j + 1].age) {
				Hero temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
        // 在 C++ 中，结构体是一个复合数据类型，赋值操作会复制整个结构体的内容，而不是仅仅交换它们的地址
			}
		}
	}
}
//打印数组
void printHeros(hero arr[], int len) {
	for (int i = 0; i < len; i++) {
		cout << "姓名： " << arr[i].name << " 性别： " << arr[i].sex << " 年龄： " << arr[i].age << endl;
	}
}

int main() {

	struct Hero arr[5] = {
		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},
	};
  int len = sizeof(arr) / sizeof(Hero); //获取数组元素个数

	bubbleSort(arr, len); //排序
  printHeros(arr, len); //打印

	return 0;
}
```
