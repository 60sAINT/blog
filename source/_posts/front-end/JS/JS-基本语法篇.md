---
title: JS - 基本语法篇
date: 2022-02-23
cover: assets/JS.png
categories:
- [前端, JavaScript]
tags:
  - JavaScript
  - 前端
---

# 初识 JavaScript

## JavaScript 是什么

+   JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言（Script 是脚本的意思）
+   脚本语言：不需要编译，运行过程中由 js 解释器 (js 引擎）逐行来进行解释并执行
+   现在也可以基于 Node.js 技术进行服务器端编程

## JavaScript 的作用

+   表单动态校验（密码强度检测） （JS 产生最初的目的）
+   网页特效
+   服务端开发 (Node.js)
+   桌面程序 (Electron)
+   App(Cordova)
+   控制硬件 - 物联网 (Ruff)
+   游戏开发 (cocos2d-js)

## HTML/CSS/JS 的关系

**HTML/CSS 标记语言 -- 描述类语言**

+   HTML 决定网页结构和内容 (决定看到什么)，相当于人的身体
+   CSS 决定网页呈现给用户的模样 (决定好不好看)，相当于给人穿衣服、化妆

**JS 脚本语言 -- 编程类语言**

+   实现业务逻辑和页面控制 (决定功能)，相当于人的各种动作

## 浏览器执行 JS 简介

浏览器分成两部分：渲染引擎和 JS 引擎

+   **渲染引擎**：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink，老版本的 webkit
+   **JS 引擎**：也称为 JS 解释器。用来读取网页中的 JavaScript 代码，对其处理后运行，比如 chrome 浏览器的 V8

浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎 (解释器) 来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。

## JS 的组成

JavaScript

+   ECMAScript（JavaScript 语法）
    
    **ECMAScript** 是由 ECMA 国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。
    
    ECMAScript：ECMAScript 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。
    
    更多参看 MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript\_technologies\_overview
    
+   DOM（文档对象模型）
    
    **文档对象模型**（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。
    
    通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。
    
+   BOM（浏览器对象模型）
    
    **BOM** (Browser Object Model，简称 BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。
    
    通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。
    

## JS 书写位置

JS 有 3 种书写位置，分别为行内、内嵌和外部。

1.  **行内式 JS**
    
    ```html
    <input type="button" value="点我试试" onclick="alert('Hello World')" />
    ```
    
    +   可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick
    +   注意单双引号的使用：在 HTML 中我们推荐使用双引号，JS 中我们推荐使用单引号
    +   可读性差，在 html 中编写 JS 大量代码时，不方便阅读；
    +   引号易错，引号多层嵌套匹配时，非常容易弄混；
    +   特殊情况下使用
2.  **内嵌 JS**
    
    ```html
    <script>    
      alert('Hello World~!');
    </script>
    ```
    
    +   可以将多行 JS 代码写到 `<script>` 标签中
    +   内嵌 JS 是学习时常用的方式
3.  **外部 JS 文件**
    
    ```html
    <script src="my.js"></script>
    ```
    
    +   利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用
    +   引用外部 JS 文件的 script 标签中间不可以写代码
    +   适合于 JS 代码量比较大的情况

# JavaScript 注释

为了提高代码的可读性，JS 与 CSS 一样，也提供了注释功能。JS 中的注释主要有两种，分别是单行注释和多行注释。

## 单行注释

为了提高代码的可读性，JS 与 CSS 一样，也提供了注释功能。JS 中的注释主要有两种，分别是单行注释和多行注释。

单行注释的注释方式如下：

```js
// 我是一行文字，不想被 JS 引擎执行，所以注释起来
```

// 用来注释单行文字（ 快捷键 ctrl + /）

## 多行注释

多行注释的注释方式如下：

```js
/*
    获取用户年龄和姓名
    并通过提示框显示出来
*/
```

/\* \*/ 用来注释多行文字（默认快捷键 alt + shift+ a）

快捷键修改为： ctrl + shift + /

vscode -> 首选项按钮 -> 键盘快捷方式 -> 查找原来的快捷键 -> 修改为新的快捷键 -> 回车确认

# JavaScript 输入输出语句

为了方便信息的输入输出，JS 中提供了一些输入输出语句，其常用的语句如下：

| 方法             | 说明                           | 归属   |
| ---------------- | ------------------------------ | ------ |
| alert(msg)       | 浏览器弹出警示框               | 浏览器 |
| console.log(msg) | 浏览器控制台打印输出信息       | 浏览器 |
| prompt(info)     | 浏览器弹出输入框，用户可以输入 | 浏览器 |

**注意：**alert () 主要用来显示消息给用户，console.log () 用来给程序员自己看运行时的消息。

# 变量

## 变量概述

**什么是变量**

白话：变量就是一个装东西的盒子。

通俗：变量是用于存放数据的容器。我们通过变量名获取数据，甚至数据可以修改。

**变量在内存中的存储**

本质：变量是程序在内存中申请的一块用来存放数据的空间。

类似我们酒店的房间，一个房间就可以看做是一个变量。

## 变量的使用

1.  **声明变量**
    
    ```js
    // 声明变量
    var age;
    // 声明一个名称为 age 的变量
    ```
    
    +   var 是一个 JS 关键字，用来声明变量 (variable 变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管
    +   age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间
2.  **赋值**
    
    ```js
    age = 10;// 给 age 这个变量赋值为 10
    
    ```
    
    +   = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思
    +   变量值是程序员保存到变量空间里的值
3.  **变量的初始化**
    
    ```js
    var age = 18;// 声明变量同时赋值为 18
    ```
    
    声明一个变量并赋值，我们称之为变量的初始化。
    

## 变量语法扩展

1.  **更新变量**
    
    一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。
    
    ```js
    var age = 18;
    age = 81;// 最后的结果就是 81 因为 18 被覆盖掉了
    ```
    
2.  **同时声明多个变量**
    
    同时声明多个变量时，只需要写一个 var，多个变量名之间使用英文逗号隔开。
    
    ```js
    var age = 10, name = 'zs', sex = 2;
    ```
    
3.  **声明变量特殊情况**
    
    | 情况                         | 说明                     | 结果      |
    | ---------------------------- | ------------------------ | --------- |
    | var age ; console.log (age); | 只声明，不赋值           | undefined |
    | console.log(age)             | 不声明，不赋值，直接使用 | 报错      |
    | age = 10; console.log (age); | 不声明，只赋值           | 10        |
    

## 变量命名规范

+   由字母 (A-Za-z)、数字 (0-9)、下划线 (\_)、美元符号 ( $ ) 组成，如：usrAge, num01, \_name
+   严格区分大小写。var app; 和 var App; 是两个变量
+   不能以数字开头。18age 是错误的
+   不能是关键字、保留字。例如：var、for、while
+   变量名必须有意义。
+   遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName

# 数据类型

## 数据类型简介

### 为什么需要数据类型

在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。

简单来说，数据类型就是数据的类别型号。比如姓名 “张三”，年龄 18，这些数据的类型是不一样的。

### 变量的数据类型

变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。\*\*JavaScript 是一种弱类型或者说动态语言。\*\* 这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。

```js
var age = 10;// 这是一个数字型
var areYouOk = '是的';// 这是一个字符串
```

在代码运行时，变量的数据类型是由 JS 引擎根据 `=` 右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。

JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：

```js
var x = 6;//x 为数字
var x = "Bill";//x 为字符串
```

### 数据类型的分类

JS 把数据类型分为两类：

+   简单数据类型（Number,String,Boolean,Undefined,Null）
+   复杂数据类型（object)

## 简单数据类型

JavaScript 中的简单数据类型及其说明如下：

| 简单数据类型 | 说明                                                 | 默认值    |
| ------------ | ---------------------------------------------------- | --------- |
| Number       | 数字型，包含整型值和浮点值，如 21、0.21              | 0         |
| Boolean      | 布尔值类型，如 true、false，等价于 1 和 0            | false     |
| String       | 字符串类型，如 "张三"。注意 js 里面字符串都带引号    | ""        |
| Undefined    | `var a;` 声明了变量 a 但是没有给值，此时 a=undefined | undefined |
| Null         | `var a = null;` 声明了变量 a 为空置                  | null      |

### 数字型 Number

JavaScript 数字类型既可以用来保存整数值，也可以保存小数 (浮点数）。

```js
var age = 21;// 整数
var Age = 21.3747;// 小数
```

1.  **数字型进制**
    
    最常见的进制有二进制、八进制、十进制、十六进制。
    
    ```js
    // 1. 八进制数字序列范围：0~7
    var num1 = 07;// 对应十进制的 7
    // 2. 十六进制数字序列范围：0~9 以及 A~F
    var num = 0xA;
    ```
    
    在 JS 中八进制前面加 0，十六进制前面加 0x
    
2.  **数字型范围**
    
    JavaScript 中数值的最大和最小值
    
    ```js
    alert(Number.MAX_VALUE);// 1.7976931348623157e+308
    alert(Number.MIN_VALUE);// 5e-324
    ```
    
    +   最大值：Number.MAX\_VALUE，这个值为：1.7976931348623157e+308
    +   最小值：Number.MIN\_VALUE，这个值为：5e-32
3.  **数字型三个特殊值**
    
    ```js
    alert(Infinity);// Infinity
    alert(-Infinity);// -Infinity
    alert(NaN);// NaN
    ```
    
    +   Infinity，代表无穷大，大于任何数值
    +   \-Infinity，代表无穷小，小于任何数值
    +   NaN ，Not a number，代表一个非数值
4.  **isNaN()**
    
    用来判断一个变量是否为非数字的类型，返回 true 或者 false
    
    isNaN(x)：
    
    +   x 是数字，返回 false
    +   x 不是数字，返回 true
    
    ```js
    var usrAge = 21;
    var isOk = isNaN(userAge);
    console.log(isNum);//false，21 不是一个非数字
    var usrName = "andy";
    console.log(isNaN(userName));//true，"andy" 是一个非数字
    ```

### 字符串型 String

字符串型可以是引号中的任意文本，其语法为双引号 "" 和单引号 ''

```js
var strMsg = "我爱北京天安门~";// 使用双引号表示字符串
var strMsg2 = '我爱吃猪蹄~';// 使用单引号表示字符串
// 常见错误
var strMsg3 = 我爱大肘子;// 报错，没使用引号，会被认为是 js 代码，但 js 没有这些语法
```

因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。

1.  **字符串引号嵌套**
    
    JS 可以用单引号嵌套双引号，或者用双引号嵌套单引号 (**外双内单，外单内双**)
    
    ```js
    var strMsg = '我是"高帅富"程序猿';// 可以用 '' 包含 ""
    var strMsg2 = "我是'高帅富'程序猿";// 也可以用 "" 包含 ''
    // 常见错误
    var badQuotes = 'What on earth?"; // 报错，不能单双引号搭配
    ```
    
2.  **字符串转义符**
    
    类似 HTML 里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。
    
    转义符都是 \\ 开头的，常用的转义符及其说明如下：
    
    | 转义符 | 解释说明                    |
    | ------ | --------------------------- |
    | \\n    | 换行符，n 是 newline 的意思 |
    | `\\`   | 斜杠 \\                     |
    | `\'`   | ' 单引号                    |
    | `\"`   | ” 双引号                    |
    | \\t    | tab 缩进                    |
    | \\b    | 空格，b 是 blank 的意思     |
    
3.  **字符串长度**
    
    字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。
    
    ```js
    var strMsg = "我是帅气多金的程序猿！";
    alert(strMsg.length);// 显示 11
    ```
    
4.  **字符串拼接**
    
    +   多个字符串之间可以使用 + 进行拼接，其拼接方式为字符串 + 任何类型 = 拼接之后的新字符串
    +   拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串
    
    ```js
    // 1.1 字符串 "相加"
    alert('hello' + ' ' + 'world');// hello world
    // 1.2 数值字符串 "相加"
    alert('100' + '100');// 100100
    // 1.3 数值字符串 + 数值
    alert('11' + 12);// 1112
    ```
    
    ```js
    console.log('我'+ 18);// 只要有字符就会相连
    var age = 18;
    //console.log (' 我 age 岁啦 ');// 这样不行
    console.log('我' + age);// 我 18
    console.log('我' + age + '岁啦'); // 我 18 岁啦
    ```
    
    +   我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值
    +   变量是不能添加引号的，因为加引号的变量会变成字符串

### 布尔型 Boolean

布尔类型有两个值：true 和 false，其中 true 表示真（对），而 false 表示假（错）。

布尔型和数字型相加的时候，true 的值为 1，false 的值为 0。

```js
console.log(true + 1);// 2
console.log(false + 1);// 1
```

### Undefined 和 Null

一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）

```js
var variable;
console.log(variable);// undefined
console.log('你好' + variable);// 你好 undefined
console.log(11 + variable);// NaN
console.log(true + variable);// NaN
```

一个声明变量给 null 值，里面存的值为空

```js
var vari = null;
console.log('你好' + vari);// 你好 null
console.log(11 + vari);// 11
console.log(true + vari);// 1
```

## 获取变量数据类型

### 获取检测变量的数据类型

typeof 可用来获取检测变量的数据类型

```js
var num = 18;
console.log(typeof num); // 结果 number
```

不同类型的返回值

| 类型      | 例               | 结果        |
| --------- | ---------------- | ----------- |
| String    | typeof "小白"    | "string"    |
| Number    | typeof 18        | "number"    |
| Boolean   | typeof true      | "boolean"   |
| Undefined | typeof undefined | "undefined" |
| Null      | typeof null      | "object"    |

### 字面量

字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。

+   数字字面量：8, 9, 10
+   字符串字面量：' 程序员 ', "大前端"
+   布尔字面量：true，false

## 数据类型转换

### 什么是数据类型转换

使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。

我们通常会实现 3 种方式的转换：

+   转换为字符串类型
+   转换为数字型
+   转换为布尔型

### 转换为字符串

| 方式               | 说明                         | 案例                                     |
| ------------------ | ---------------------------- | ---------------------------------------- |
| toString()         | 转成字符串                   | var num = 1; alert(num.toString());      |
| String () 强制转换 | 转成字符串                   | var num = 1; alert(String(num));         |
| **加号拼接字符串** | 和字符串拼接的结果都是字符串 | var num = 1; alert (num + "我是字符串"); |

+   toString () 和 String () 使用方式不一样。
+   三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。

### 转换为数字型

| 方式                     | 说明                           | 案例                 |
| ------------------------ | ------------------------------ | -------------------- |
| parseInt (String) 函数   | 将 string 类型转成整数数值型   | parseInt('78');      |
| parseFloat (string) 函数 | 将 string 类型转成浮点数数值型 | parseFloat('78.21'); |
| Number () 强制转换函数   | 将 string 类型转换为数值型     | Number('12');        |
| js 隐式转换（- \* /）    | 利用算数运算隐式转换为数值型   | '12' - 0             |

+   注意 parseInt 和 parseFloat 单词的大小写
+   隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型

### 转换为布尔型

| 方式            | 说明               | 案例             |
| --------------- | ------------------ | ---------------- |
| Boolean () 函数 | 其他类型转成布尔值 | Boolean('true'); |

+   代表空、否定的值会被转换为 false，如 ''、0、NaN、null、undefined
+   其余值都会被转换为 true

```js
console.log(Boolean(''));// false
console.log(Boolean(0));// false
console.log(Boolean(NaN));// false
console.log(Boolean(null));// false
console.log(Boolean(undefined));// false
console.log(Boolean('小白');// true
console.log(Boolean(12));// true
```

# 运算符

## 运算符的分类

**运算符**（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。

JavaScript 中常用的运算符有：

+   算术运算符
+   递增和递减运算符
+   比较运算符
+   逻辑运算符
+   赋值运算符

## 算术运算符

+   算术运算符概述
    
    概念：算术运算使用的符号，用于执行两个变量或值的算术运算。
    
    | 运算符 | 描述           | 实例                 |
    | ------ | -------------- | -------------------- |
    | +      | 加             | 10+20=30             |
    | \-     | 减             | 10-20=-10            |
    | \*     | 乘             | 10\*20=200           |
    | /      | 除             | 10/20=0.5            |
    | %      | 取余数（取模） | 返回除法的余数 9%2=1 |
    
+   浮点数的精度问题
    
    浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。
    
    ```js
    var result = 0.1 + 0.2;// 结果不是 0.3，而是：0.30000000000000004
    console.log(0.07 * 100);// 结果不是 7，而是：7.000000000000001
    ```
    
    所以：不要直接判断两个浮点数是否相等！
    
+   表达式和返回值
    
    表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合
    
    简单理解：是由数字、运算符、变量等组成的式子
    
    表达式最终都会有一个结果，返回给开发者，称为返回值
    

## 递增和递减运算符

+   递增和递减运算符概述
    
    如果需要反复给数字变量添加或减去 1，可以使用递增（++）和递减（--）运算符来完成。
    
    在 JavaScript 中，递增（++）和递减（--）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。
    
    注意：递增和递减运算符必须和变量配合使用。
    
+   递增运算符
    
    +   前置递增运算符
        
        num 前置递增，就是自加 1，类似于 num = num + 1，但是 num 写起来更简单。
        
        先自加，后返回值
        
        ```js
        var num = 10;
        alert(++num + 10);// 21
        ```
        
    +   后置递增运算符
        
        num 后置递增，就是自加 1，类似于 num = num + 1，但是 num 写起来更简单。
        
        先返回原值，后自加
        
        ```js
        var num = 10;
        alert(10 + num++);// 20
        ```

## 比较运算符

+   比较运算符概述
    
    概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true /false）作为比较运算的结果。
    
    | 运算符名称   | 说明                         | 案例        | 结果  |
    | ------------ | ---------------------------- | ----------- | ----- |
    | <            | 小于号                       | 1 < 2       | true  |
    | \>           | 大于号                       | 1 > 2       | false |
    | \>=          | 大于等于号（大于或者等于）   | 2 >= 2      | true  |
    | <=           | 小于等于号（小于或者等于）   | 3 <= 2      | false |
    | \==          | 判等号（会转型）             | 37 == 37    | true  |
    | !=           | 不等号                       | 37 != 37    | false |
    | `===` `!===` | 全等，要求值和数据类型都一致 | 37 === '37' | false |
    
+   等号比较
    
    | 符号 | 作用 | 用法                                   |
    | ---- | ---- | -------------------------------------- |
    | \=   | 赋值 | 把右边给左边                           |
    | \==  | 判断 | 判断两边是否相等（注意此时有隐式转换） |
    | \=== | 全等 | 判断两边的值和数据类型是否完全相同     |
    
    <table><tbody><tr><td data-num="1"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">==</span> <span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">18</span> <span class="token operator">===</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></tbody></table>
    

## 逻辑运算符

+   逻辑运算符概述
    
    概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断
    
    | 逻辑运算符 | 说明                       | 案例          |
    | ---------- | -------------------------- | ------------- |
    | &&         | ” 逻辑与 “，简称” 与 “ and | true && false |
    |            |                            |               |
    | !          | ” 逻辑非 “，简称” 非 “ not | !true         |
    
+   逻辑与 &&
    
    两边都是 true 才返回 true，否则返回 false
    
+   逻辑或 ||
    
    两边都是 false 才返回 false，否则返回 true
    
+   逻辑非！
    
    逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false
    
    ```js
    var isOk = !true;
    console.log(isOk);// false
    ```
    
+   短路运算（逻辑中断）
    
    短路运算的原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值；
    
    +   逻辑与
        
        语法：表达式 1 && 表达式 2
        
        如果第一个表达式的值为真，则返回表达式 2
        
        如果第一个表达式的值为假，则返回表达式 1
        
        ```js
        console.log(123 && 456);// 456
        console.log(0 && 456);// 0
        console.log(123 && 456 && 789);// 789
        ```
        
    +   逻辑或
        
        语法：表达式 1|| 表达式 2
        
        如果第一个表达式的值为真，则返回表达式 1
        
        如果第一个表达式的值为假，则返回表达式 2
        
        ```js
        console.log(123 || 456);// 123
        console.log(0 || 456);// 456
        console.log(123 || 456 || 789);// 123
        ```

## 赋值运算符

概念：用来把数据赋值给变量的运算符。

| 赋值运算符  | 说明                 | 案例                         |
| ----------- | -------------------- | ---------------------------- |
| \=          | 直接赋值             | var usrName = ' 我是值 ';    |
| +=、-=      | 加、减一个数后再赋值 | var age = 10; age += 5;// 15 |
| \*=、/=、%= | 乘、除、取模后再赋值 | var age = 2; age \*= 5;// 10 |

```js
var age = 10;
age += 5;// 相当于 age = age + 5;
age -= 5;// 相当于 age = age - 5;
age *= 10;// 相当于 age = age * 10;
```

## 运算符优先级

| 优先级 | 运算符     | 顺序                  |
| ------ | ---------- | --------------------- |
| 1      | 小括号     | ()                    |
| 2      | 一元运算符 | ++ -- !               |
| 3      | 算术运算符 | **先 \* / %，后 + -** |
| 4      | 关系运算符 | \> >= < <=            |
| 5      | 相等运算符 | `==` `!=` `===` `!==` |
| 6      | 逻辑运算符 | **先 &&，后           |
| 7      | 赋值运算符 | \=                    |
| 8      | 逗号运算符 | ,                     |

+   一元运算符里面的逻辑非优先级很高
+   逻辑与比逻辑或优先级高

# 流程控制

## 流程控制概念

在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解：**流程控制就是来控制代码按照一定结构顺序来执行**

流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。

## 顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

## 分支流程控制

+   分支结构
    
    由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果
    
    JS 语言提供了两种分支结构语句：if 语句、switch 语句
    
+   if 语句
    
    ```js
    // 条件成立执行代码，否则什么也不做
    if (条件表达式) {
        // 条件成立执行的代码语句
    }
    ```
    
+   if else 语句（双分支语句）
    
    ```js
    // 条件成立 执行 if 里面代码，否则执行 else 里面的代码
    if (条件表达式) {
         // [如果] 条件成立执行的代码
    } 
    else {
         // [否则] 执行的代码
    }
    ```
    
+   if else if 语句（多分支语句）
    
    ```js
    // 适合于检查多重条件。
    if (条件表达式1) {
         语句1；
    } 
    else if (条件表达式2) {
         语句2；
    } 
    else if (条件表达式3) {
         语句3；
         ....
    } 
    else {
         // 上述条件都不成立执行此处代码
    }
    ```
    

+   三元表达式
    
    三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式
    
    1.  语法结构
        
        ```js
        表达式1 ? 表达式2 : 表达式3;
        ```
        
    2.  执行思路
        
        +   如果表达式 1 为 true ，则返回表达式 2 的**值**，如果表达式 1 为 false，则返回表达式 3 的**值**
        +   简单理解： 就类似于 if else （双分支） 的简写
+   switch 语句
    
    1.  语法结构
        
        switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。
        
        ```js
        switch( 表达式 ){
             case value1:
             	// 表达式 等于 value1 时要执行的代码
             	break;
             case value2:
             	// 表达式 等于 value2 时要执行的代码
             	break;
             default:
             	// 表达式 不等于任何一个 value 时要执行的代码
        }
        ```
        
        +   switch ：开关 转换 ， case ：小例子 选项
        +   关键字 switch 后面**括号内**可以是**表达式**或**值**， 通常是一个**变量**
        +   关键字 **case** , 后跟一个选项的表达式或值，**后面跟一个冒号**
        +   switch 表达式的值会与结构中的 case 的值做比较
        +   如果存在匹配**全等** (===) ，则与该 case 关联的代码块会被执行，并在遇**到 break 时停止**，整个 switch 语句代码执行结束
        +   如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码
        
        **注意：** *执行 case 里面的语句时，如果没有 break，则继续执行下一个 case 里面的语句。*
        
    2.  switch 语句和 if else if 语句的区别
        
        1.  一般情况下，它们两个语句可以相互替换
        2.  switch...case 语句通常处理 case 为比较确定值的情况， 而 if…else… 语句更加灵活，常用于范围判断 (大于、等于某个范围)
        3.  switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而 if…else 语句有几种条件，就得判断多次。
        4.  当分支比较少时，if… else 语句的执行效率比 switch 语句高。
        5.  当分支比较多时，switch 语句的执行效率比较高，而且结构更清晰。

## 循环流程控制

**循环目的**

+   在实际问题中，有许多具有*规律性的重复操作*，因此在程序中要完成这类操作就需要*重复执行某些语句*

**JS 中的循环**

再 JS 中，主要有三种类型的循环语句：

+   for 循环
+   while 循环
+   do...while 循环

### for 循环

在程序中，一组被重复执行的语句被称之为*循环体*，能否继续重复执行，取决于循环的*终止条件*。由循环体及循环的终止条件组成的语句，被称之为**循环语句**

+   语法结构
    
    for 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：
    
    ```js
    for(初始化变量; 条件表达式; 操作表达式 ){
         // 循环体
    }
    ```
    
    +   **初始化变量：** 通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。
        
    +   **条件表达式：** 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。
        
    +   **操作表达式：** 每次循环的最后都要执行的表达式。通常被用于更新或者递增计数器变量。当然，递减变量也是可以的。
    
    *初始化操作在整个 for 循环只会执行一次*
    
    **断点调试：**
    
    断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。
    
    *断点调试可以帮我们观察程序的运行过程*
    
    浏览器中按 F12--> sources --> 找到需要调试的文件 --> 在程序的某一行设置断点
    
    Watch: 监视，通过 watch 可以监视变量的值的变化，非常的常用。
    
    F11: 程序单步执行，让程序一行一行的执行，这个时候，观察 watch 中变量的值的变化。
    
+   for 循环重复相同的代码
    
    for 循环可以重复相同的代码 ，比如我们要输出 10 句 “我要上川大”
    
    ```js
    // 基本写法
    for(var i = 1; i <= 10; i++){
         console.log('我要上川大');
    }
    // 用户输入次数
    var num = prompt('请输入次数:')；
    for ( var i = 1 ; i <= num; i++) {
         console.log('我要上川大');
    }
    ```
    
+   for 循环重复不相同的代码
    
    for 循环还可以重复不同的代码，这主要是因为使用了计数器 ，计数器在每次循环过程中都会有变化。
    
    例如，求输出一个人 1 到 100 岁：
    
    ```js
    // 基本写法
    for (var i = 1; i <= 100; i++) {
         console.log('这个人今年' + i + '岁了');
    }
    //for 里面是可以添加其他语句的
    for (var i = 1; i <= 100; i++) {
        if (i == 1) {
        	console.log('这个人今年1岁了， 它出生了');
        } 
        else if (i == 100) {
        	console.log('这个人今年100岁了，它死了');
         } 
        else {
        	console.log('这个人今年' + i + '岁了');
        }
    }
    ```
    
+   for 循环重复某些相同操作
    
    for 循环因为有了计数器的存在，我们还可以重复的执行某些操作，比如做一些算术运算。
    

### 双重 for 循环

+   双重 for 循环概述
    
    很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。
    
    **循环嵌套**是指*在一个循环语句中再定义一个循环语句的语法结构*，例如在 for 循环语句中，可以再嵌套一个 for 循环，这样的 for 循环语句我们称之为*双重 for 循环*
    
+   双重 for 循环语法
    
    ```js
    for (外循环的初始; 外循环的条件; 外循环的操作表达式) {
    	for (内循环的初始; 内循环的条件; 内循环的操作表达式) {
    		需执行的代码;
    	}
    }
    ```
    
    +   内层循环可以看做外层循环的语句
        
    +   内层循环执行的顺序也要遵循 for 循环的执行顺序
        
    +   外层循环执行一次，内层循环要执行全部次数
    
+   打印三行三列星星
    
    核心：
    
    1\. 内层循环负责一行打印三个星星
    
    2\. 外层循环负责打印三行
    
    ```js
    var star = '';
    for (var j = 1; j <= 3; j++) {
    	for (var i = 1; i <= 3; i++) {
    		star += '☆'
    	}
    	// 每次满 5 个星星 就 加一次换行
    	star += '\n'
    }
    console.log(star);
    ```

### while 循环

while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环

while 语句的语法结构如下：

```js
while (条件表达式) {
	// 循环体代码
}
```

**执行思路**

① 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码

② 执行循环体代码

③ 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为 true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束

**注意：**

① 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环

② while 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如判断用户名和密码

### do while 循环

do... while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。

do... while 语句的语法结构如下：

```js
do {
	// 循环体代码 - 条件表达式为 true 时重复执行循环体代码
} while(条件表达式);
```

**执行思路：**

① 先执行一次循环体代码

② 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码

**注意：**先执行循环体，再判断，我们会发现 do…while 循环语句**至少会执行一次循环体代码**

### continue break

+   continue 关键字
    
    **continue 关键字**用于立即**跳出本次循环**，**继续下一次循环**（本次循环体中 continue 之后的代码就会少执行一次）。
    
    例如，吃 5 个包子，第 3 个有虫子，就扔掉第 3 个，继续吃第 4 个第 5 个包子，其代码实现如下：
    
    ```js
    for (var i = 1; i <= 5; i++) {
    	if (i == 3) {
    		console.log('这个包子有虫子，扔掉');
    		continue; // 跳出本次循环，跳出的是第 3 次循环
    	}
    	console.log('我正在吃第' + i + '个包子呢');
    }
    ```
    
+   break 关键字
    
    **break 关键字用于**立即**跳出整个循环**（循环结束）。
    
    例如，吃 5 个包子，吃到第 3 个发现里面有半个虫子，其余的不吃了，其代码实现如下：
    
    ```js
    for (var i = 1; i <= 5; i++) {
    	if (i == 3) {
    		break; // 直接退出整个 for 循环，跳到整个 for 下面的语句
    	}
    	console.log('我正在吃第' + i + '个包子呢');
    }
    ```

# JavaScript 命名规范

## 标识符命名规范

+   变量、函数的命名必须要有意义
+   变量的名称一般用名词
+   函数的名称一般用动词

## 操作符规范

```js
// 操作符的左右两侧各保留一个空格
for (var i = 1; i <= 5; i++) {
    if (i == 3) {
        break;
    }
    console.log('我正在吃第' + i + '个包子呢');
}
```

## 单行注释规范

```js
for (var i = 1; i <= 5; i++) {
    if (i == 3) {
        break;// 单行注释前面注意有个空格
    }
    console.log('我正在吃第' + i + '个包子呢');
}
```

# JavaScript 数组

## 数组的概念

数组（Array）可以把一组相关的数据一起存放，并提供方便的访问 (获取）方式。

数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一 种将一组数据存储在单个变量名下的优雅方式。

```js
// 普通变量一次只能存储一个值
var num = 10; 
// 数组一次可以存储多个值
var arr = [1,2,3,4,5]
```

## 创建数组

### 利用 new 创建数组

```js
var 数组名 = new Array() ；
var arr = new Array(); // 创建一个新的空数组
```

### 利用数组字面量创建数组

```js
//1. 使用数组字面量方式创建空的数组
var 数组名 = []；
//2. 使用数组字面量方式创建带初始值的数组
var 数组名 = ['小白','小黑','大黄','瑞奇'];
```

+   数组的字面量是方括号 \[ \]
+   声明数组并赋值称为数组的初始化
+   这种字面量方式也是最多使用的方式

### 数组元素的类型

数组中可以存放**任意类型**的数据，例如字符串，数字，布尔值等

```js
var arrStus = ['小白', 12, true, 28.9];
```

## 数组的索引

**索引 (下标) ：** 用来访问数组元素的序号（数组下标从 0 开始）。

数组可以通过**索引**来访问、设置、修改对应的数组元素，我们可以通过 “数组名 \[索引\]” 的形式来获取数组中的元素。

这里的**访问**就是获取得到的意思

```js
// 定义数组
var arrStus = [1,2,3];
// 获取数组中的第 2 个元素
alert(arrStus[1]);
```

## 遍历数组

**遍历:** 就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名）。 我们可以通过 for 循环索引遍历数组中的每一项

```js
var arr = ['red','green', 'blue'];
for(var i = 0; i < arr.length; i++) {
	console.log(arrStus[i]);
}
```

## 数组的长度

使用 “数组名.length” 可以访问数组元素的数量（数组长度）。

```js
var arrStus = [1,2,3];
alert(arrStus.length); // 3
```

**注意：**

1.  此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。
2.  当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化。

## 数组中新增元素

### 通过修改 length 长度新增数组元素

+   可以通过修改 length 长度来实现数组扩容的目的
+   length 属性是可读写的

```js
var arr = ['red', 'green', 'blue', 'pink'];
arr.length = 7;
console.log(arr);
console.log(arr[4]);
console.log(arr[5]);
console.log(arr[6]);
```

其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined。

### 通过修改数组索引新增数组元素

+   可以通过修改数组索引的方式追加数组元素
+   不能直接给数组名赋值，否则会覆盖掉以前的数据

```js
var arr = ['red', 'green', 'blue', 'pink'];
arr[4] = 'hotpink';
console.log(arr);
```

这种方式也是最常用的一种方式

# JavaScript 函数

## 函数的概念

在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

虽然 for 循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。

**函数**：就是封装了一段可被重复调用执行的**代码块**。通过此代码块可以实现大量代码的重复使用。

## 函数的使用

函数在使用时分为两步：声明函数和调用函数。

### 声明函数

```js
// 声明函数
function 函数名() {
	// 函数体代码
}
```

+   function 是声明函数的关键字，必须小写
+   由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如 getSum

### 调用函数

```js
// 调用函数
函数名();
// 通过调用函数名来执行函数体代码
```

+   调用的时候千万不要忘记添加小括号
+   函数不调用，自己不执行。

**注意：** 声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

### 函数的封装

+   函数的封装是把一个或者多个功能通过**函数的方式封装起来**，对外只提供一个简单的函数接口
+   简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）

## 函数的参数

### 形参和实参

在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为**实参**。

| 参数     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| **形参** | **形**式上的参数，**函数定义**的时候传递的参数，当前并不知道是什么 |
| 实参     | **实**际上的参数，**函数调用**的时候传递的参数，实参是传递给形参的 |

**参数的作用:** 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

```js
// 带参数的函数声明
function 函数名(形参1, 形参2, 形参3...) {
    // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...);
```

### 函数参数的传递过程

```js
// 声明函数
function getSum(num1, num2) {
    console.log(num1 + num2);
}
// 调用函数
getSum(1, 3);// 4
getSum(6, 5);// 11
```

1.  调用的时候实参值是传递给形参的
2.  形参简单理解为：**不用声明的变量**
3.  实参和形参的多个参数之间用逗号（,）分隔

### 函数形参和实参个数不匹配问题

| 参数个数         | 说明                                 |
| ---------------- | ------------------------------------ |
| 实参等于形参个数 | 输出正确结果                         |
| 实参多于形参个数 | 只取到形参的个数                     |
| 实参小于形参个数 | 多的形参定义为 undefined，结果为 NaN |

```js
function sum(num1, num2) {
	console.log(num1 + num2);
}
sum(100, 200);// 形参和实参个数相等，输出正确结果
sum(100, 400, 500, 700);// 实参个数多于形参，只取到形参的个数
sum(200);// 实参个数少于形参，多的形参定义为 undefined，结果为 NaN
```

**注意**：在 JavaScript 中，形参的默认值是 undefined。

## 函数的返回值

### return 语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

return 语句的语法格式如下：

```js
// 声明函数
function 函数名() {
    ...
    return 需要返回的值;
}
// 调用函数
函数名();// 此时调用函数就可以得到函数体内 return 后面的值
```

+   在使用 return 语句时，函数会停止执行，并返回指定的值
+   如果函数没有 return，返回的值是 undefined

```js
// 声明函数
function sum() {
    ...
    return 666;
}
// 调用函数
sum();// 此时 sum 的值就等于 666，因为 return 语句会把自身后面的值返回给调用者
```

### return 终止函数

return 语句之后的代码不被执行。

```js
function add(num1, num2) {
    // 函数体
    return num1 + num2;// 注意：return 后的代码不执行
    alert('我不会被执行，因为前面有return');
}
var resNum = add(21, 6);// 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);// 27
```

### return 的返回值

**return 只能返回一个值**。如果用逗号隔开多个值，以**最后一个**为准。

```js
function add(num1，num2) {
    // 函数体
    return num1, num2;
}
var resNum = add(21,6);// 调用函数，传入两个实参，并通过 resNum 接收函数返回值
alert(resNum);// 6
```

## arguments 的使用

当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。

**arguments 展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：

+   具有 length 属性
+   按索引方式储存数据
+   不具有数组的 push,pop 等方法

```js
// 利用函数求任意个数的最大值
function maxValue() {
    var max = arguments[0];
    for (var i = 0; i < arguments.length; i++) {
        if (max < arguments[i]) {
            max = arguments[i];
        }
    }
    return max;
}
console.log(maxValue(2, 4, 5, 9));
console.log(maxValue(12, 4, 9));
```

## 函数的两种声明方式

### 自定义函数方式（命名函数）

利用函数关键字 function 自定义函数方式。

```js
	
// 声明定义方式
function fn() {
    ...
}
// 调用
fn();
```

+   因为有名字，所以也被称为命名函数
+   调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

### 函数表达式方式（匿名函数）

```js
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function() {
    ...
}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

+   因为函数没有名字，所以也被称为匿名函数
+   这个 fn 里面存储的是一个函数
+   函数表达式方式原理跟声明变量方式是一致的
+   函数调用的代码必须写到函数体后面

# 作用域

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

JavaScript（es6 前）中的作用域有两种：

+   全局作用域
    
    作用于所有代码执行的环境 (整个 script 标签内部) 或者一个独立的 js 文件。
    
+   局部作用域（函数作用域）
    
    作用于函数内的代码环境，就是局部作用域。因为跟函数有关系，所以也称为函数作用域。
    
+   JS 没有块级作用域（在 ES6 之前）
    
    块作用域由 { } 包括。
    
    在其他编程语言中（如 java、c# 等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的 Java 代码：
    
    ```js
    //java 有块级作用域
    if (true) {
        int num = 123;
        system.out.print(num);// 123
    }
    system.out.print(num);// 报错，因为代码中 {} 即一块作用域，其中声明的变量 num，在 “{}” 之外不能使用
    ```
    
    而与之类似的 JavaScript 代码，则不会报错：
    
    ```js
    if (true) {
        var num = 123;
        console.log(num);// 123
    }
    console.log(num);// 123
    ```

## 变量的作用域

在 JavaScript 中，根据作用域的不同，变量可以分为两种：

+   全局变量
+   局部变量

1.  全局变量
    
    在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。
    
    +   全局变量在代码的任何位置都可以使用
    +   在全局作用域下 var 声明的变量是全局变量
    +   特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）
2.  局部变量
    
    在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）
    
    +   局部变量只能在该函数内部使用
    +   在函数内部 var 声明的变量是局部变量
    +   函数的形参实际上就是局部变量
3.  全局变量和局部变量的区别
    
    +   全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
    +   局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间

## 作用域链

如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在 **[内部函数可以访问外部函数变量]** 的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

```js
function f1() {
    var num = 123;
    function f2() {
        console.log(num);
    }
    f2();
}
var num = 456;
f1();// 123
```

作用域链：采取就近原则的方式来查找变量最终的值。

```js
var a = 1;
function fn1() {
    var a = 2;
    var b = '22';
    fn2();
    function fn2() {
        var a = 3;
        fn3();
        function fn3() {
            var a = 4;
            console.log(a);// 4
            console.log(b);// 22
        }
    }
}
fn1();
```

## 预解析

JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。

+   预解析：在当前作用域下，JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。
+   代码执行：从上到下执行 JS 语句。

**预解析会把变量和函数的声明在代码执行之前执行完成。**

### 变量预解析

变量提升（变量预解析）：变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。

```js
console.log(num); //undefined
var num = 10;
```

### 函数预解析

函数提升：函数的声明会被提升到当前作用域的最上面，但是不会调用函数。

```js
fn();
function fn() {
	console.log('打印');
}
// 结果：控制台打印字符串 ---” 打印 “

```

**函数表达式声明函数问题：**

函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用

```js
fn();
var fn = function() {
    console.log('想不到吧');
}
// 结果：报错提示”fn is not a function"
// 解释：该段代码执行之前，会做变量声明提升，fn 在提升之后的值是 undefined；而 fn 调用是在 fn 被赋值为函数体之前，此时 fn 的值是 undefined，所以无法正确调用
```

# 对象

## 对象的相关概念

+   在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的。
+   属性：事物的特征，在对象中用属性来表示（常用名词）
+   方法：事物的行为，在对象中用方法来表示（常用动词）

保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。

```js
// 如果要保存一个人的完整信息呢？
// 例如，将 “张三” 的个人的信息保存在数组中的方式为：
var arr = ['张三', '男', 128, 154];
```

用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清楚所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。

为了更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。

使用对象记录上组数据为：

```js
var obj = {
    "name": "张三疯",
    "sex": "男",
    "age": 128,
    "height": 154
}
```

JS 中的对象表达结构更清晰，更强大。

## 创建对象的三种方式

### 使用对象字面量创建对象

就是花括号 {} 里面包含了表达这个具体事物（对象）的属性和方法；{} 里面采取键值对的形式表示

+   键：相当于属性名
+   值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）

```js
var star = {
    name: 'blue',
    age: 19,
    sex: '女',
    sayHi: function() {
        alert('大家好啊~');
    }
}
```

### 利用 new Object 创建对象

+   创建空对象
    
    ```js
    var andy = new Obect();
    ```
    
    通过内置构造函数 Object 创建对象，此时 andy 变量已经保存了创建出来的空对象
    
+   给空对象添加属性和方法
    
    通过对象操作属性和方法的方式，来为对象增加属性和方法
    
    ```js
    andy.name = 'blue';
    andy.age = 19;
    andy.sex = '女';
    andy.sayHi = function() {
        alert('大家好啊~');
    }
    ```

### 利用构造函数创建对象

+   构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。
    
+   构造函数的封装格式：
    
    ```js
    function 构造函数名(形参1, 形参2, 形参3) {
        this.属性名1 = 参数1;
        this.属性名2 = 参数2;
        this.属性名3 = 参数3;
        this.方法名 = 函数体;
    }
    ```
    
+   构造函数的调用格式
    
    ```js
    var obj = new 构造函数名(实参1, 实参2, 实参3);
    ```
    
    以上代码中，obj 即接收到构造函数创建出来的对象。
    
+   注意事项
    
    1.  构造函数约定**首字母大写。**
    2.  函数内的属性和方法前面需要添加 **this**，表示当前对象的属性和方法。
    3.  构造函数中**不需要 return 返回结果**。
    4.  当我们创建对象的时候，**必须用 new 来调用构造函数**。
    5.  构造函数，如 Stars ()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）
    6.  构造函数，如 Stars ()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）
+   new 关键字的作用
    
    1.  在构造函数代码开始执行之前，创建一个空对象；
    2.  修改 this 的指向，把 this 指向创建出来的空对象；
    3.  执行函数的代码
    4.  在函数完成之后，返回 this--- 即创建出来的对象

## 对象的使用

+   对象的属性
    
    对象中存储**具体数据**的 "键值对" 中的 "键" 称为对象的属性，即对象中存储具体数据的项
    
+   对象的方法
    
    对象中存储函数的 "键值对" 中的 "键" 称为对象的方法，即对象中存储函数的项
    
+   访问对象的属性
    
    +   对象里面的属性调用：对象.属性名，这个小点.就理解为 “的”
    +   对象里面属性的另一种调用方式：对象 \[‘属性名’\]，注意方括号里面的属性必须加引号
    
    ```js
    console.log(star.name);// 调用名字属性
    console.log(star['name']);// 调用名字属性
    ```
    
+   调用对象的方法
    
    对象里面的方法调用：对象。方法名 ()，注意这个方法名字后面一定加括号
    
    ```js
    star.sayHi();// 调用 sayHi 方法，注意，一定不要忘记带后面的括号
    ```

## 遍历对象

for...in 语句用于对数组或者对象的属性进行循环操作。

```js
for (变量 in 对象名字) {
    // 在此执行代码
}
```

语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。

```js
for (var k in obj) {
    console.log(k);// 这里的 k 是属性名
    console.log(obj[k]);// 这里的 obj [k] 是属性值
}
```

# JavaScript 内置对象

+   JavaScript 中的对象分为 3 种：自定义对象、内置对象、浏览器对象
+   前面两种对象是 JS 基础内容，属于 ECMAScript；第三个浏览器对象属于 JS 独有，JS API 讲解
+   内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）
+   内置对象最大的优点就是帮助我们快速开发
+   JavaScript 提供了多个内置对象：Math、Date、Array、String 等

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过 MDN/W3C 来查询。

Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。

MDN:https://developer.mozilla.org/zh-CN/

**如何学习对象中的方法：**

1.  查阅该方法的功能
2.  查看里面参数的意义和类型
3.  查看返回值的意义和类型
4.  通过 demo 进行测试

## Math 对象

### Math 概述

Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。

```js
Math.PI// 圆周率
Math.floor()// 向下取整
Math.ceil()// 向上取整
Math.round()// 四舍五入版就近取整，注意 - 3.5 结果是 - 3
Math.abs()// 绝对值
Math.max()/Math.min()// 求最大和最小值
```

### 随机数方法 random ()

random () 方法可以随机返回一个小数，其取值范围是 \[0，1)，左闭右开 0 <= x < 1

得到一个两数之间的随机整数，包括两个数在内:

```js
function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
```

## 日期对象

+   Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用
+   Date 实例用来处理日期和时间

### Date () 方法的使用

1.  **获取当前时间必须实例化**
    
    ```js
    var now = new Date();
    console.log(now);// Wed Jul 26 2023 14:52:46 GMT+0800 (中国标准时间)
    
    ```
    
2.  **Date () 构造函数的参数**
    

如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’，可以写成 new Date ('2019-5-1') 或者 new Date ('2019/5/1')

+   如果 Date () 不写参数，就返回当前时间
+   如果 Date () 里面写参数，就返回括号里面输入的时间

### 日期格式化

我们想要 2019-8-8 8:8:8 格式的日期，要怎么办？

需要获取日期指定的部分，所以我们要手动的得到这种格式。

| 方法名        | 说明                          | 代码               |
| ------------- | ----------------------------- | ------------------ |
| getFullYear() | 获取当年                      | dObj.getFullYear() |
| getMonth()    | 获取当月（0-11）              | dObj.getMonth()    |
| getDate()     | 获取当天日期                  | dObj.getDate()     |
| getDay()      | 获取星期几（周日 0 到周六 6） | dObj.getDay()      |
| getHours()    | 获取当前小时                  | dObj.getHours()    |
| getMinutes()  | 获取当前分钟                  | dObj.getMinutes()  |
| getSeconds()  | 获取当前秒钟                  | dObj.getSeconds()  |

### 获取日期的总的毫秒形式

Date 对象是基于 1970 年 1 月 1 日（世界标准时间）起的毫秒数（时间戳）

我们经常利用总的毫秒数来计算时间，因为它更精确

```js
// 实例化 Date 对象
var date = new Date();
// 1. 用于获取对象的原始值
console.log(date.valueOf());// 1690353452935（就是我们现在时间距离 1970.1.1 总的毫秒数）
console.log(date.getTime());// 1690353452935
// 2. 简单写可以这么做（最常用的写法）
var date1 = +new Date();// +new Date () 返回的就是总的毫秒数
console.log(date1);
// 3. HTML5 中提供的方法
console.log(Date.now());
```

## 数组对象

### 检测是否为数组

+   instanceof 运算符，可以判断一个对象是否属于某种类型
+   Array.isArray () 用于判断一个对象是否为数组，isArray () 是 HTML5 中提供的方法

```js
var arr = [1, 23];
var obj = {};
console.log(arr instanceof Array);// true
console.log(obj instanceof Array);// false
console.log(Array.isArray(arr));// true
console.log(Array.isArray(obj));// false
```

### 添加删除数组元素

| 方法名              | 说明                                                     | 返回值                                 |
| ------------------- | -------------------------------------------------------- | -------------------------------------- |
| push (参数 1...)    | 末尾添加一个或多个元素，注意修改原数组                   | 并返回新的长度                         |
| pop()               | 删除数组最后一个元素，把数组长度减 1，无参数，修改原数组 | 返回它删除的元素的值                   |
| unshift (参数 1...) | 向数组的开头添加一个或更多元素，注意修改原数组           | 并返回新的长度                         |
| shift()             | 删除数组中的第一个元素，数组长度减 1，无参数，修改原数组 | 并返回第一个元素的值                   |
| slice()             | 数组截取 slice (begin, end)，结束索引不包含在提取结果中  | 返回被截取项目的新数组，不会修改原数组 |
| splice()            | 数组删除 splice (第几个开始，要删除个数)                 | 返回被删除项目的新数组，会影响原数组   |

### 数组排序

| 方法名    | 说明                         | 是否修改原数组                     |
| --------- | ---------------------------- | ---------------------------------- |
| reverse() | 颠倒数组中元素的顺序，无参数 | 该方法会改变原来的数组，返回新数组 |
| sort()    | 对数组的元素进行排序         | 该方法会改变原来的数组，返回新数组 |

```js
var arr = [1, 64, 9, 6];
arr.sort(function(a, b) {
    return b - a;// 降序
    //return a - b;// 升序
});
console.log(arr);
```

### 数组索引方法

| 方法名        | 说明                           | 返回值                                 |
| ------------- | ------------------------------ | -------------------------------------- |
| indexOf()     | 数组中查找给定元素的第一个索引 | 如果存在返回索引号，如果不存在返回 - 1 |
| lastIndexOf() | 在数组中的最后一个的索引       | 如果存在返回索引号，如果不存在返回 - 1 |

### 数组转换为字符串

| 方法名            | 说明                                       | 返回值         |
| ----------------- | ------------------------------------------ | -------------- |
| toString()        | 把数组转换成字符串，逗号分隔每一项         | 返回一个字符串 |
| join (' 分隔符 ') | 方法用于把数组中的所有元素转换为一个字符串 | 返回一个字符串 |

### 连接数组

| 方法名   | 说明                             | 返回值           |
| -------- | -------------------------------- | ---------------- |
| concat() | 连接两个或多个数组，不影响原数组 | 返回一个新的数组 |

## 字符串对象

### 基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number 和 Boolean。

**基本包装类型**就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

```js
// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
```

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下：

```js
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
```

### 字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```js
var str = 'abc';
str = 'hello';
// 当重新给 str 赋值的时候，常量 'abc' 不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = '';
for (var i = 0; i < 100000; i++) {
	str += i;
}
console.log(str);
// 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```

### 根据字符返回位置

字符串所有的方法，都不会修改字符串本身 (字符串是不可变的)，操作完成会返回一个新的字符串。

| 方法名                                 | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| indexOf (' 要查找的字符 ', 开始的位置) | 返回指定内容在原字符串中的位置，如果找不到就返回 - 1，开始的位置是 index 索引号 |
| lastIndexOf()                          | 从后往前找，只找第一个匹配的                                 |

### 根据位置返回字符

| 方法名            | 说明                                          | 使用                       |
| ----------------- | --------------------------------------------- | -------------------------- |
| charAt(index)     | 返回指定位置的字符（index 字符串的索引号）    | str.charAt(0)              |
| charCodeAt(index) | 获取指定位置处字符的 ASCII 码（index 左引号） | str.charCodeAt(0)          |
| str\[index\]      | 获取指定位置处字符                            | HTML5 支持，和 charAt 等效 |

### 字符串操作方法

| 方法名                       | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| concact(str1, str2, str3...) | concat () 方法用于连接两个或多个字符串。拼接字符串，等效于 +，+ 更常用 |
| substr(start, length)        | 从 start 位置开始（索引号），length 取的个数                 |
| slice(start, end)            | 从 start 位置开始，截取到 end 位置，end 取不到。接受负数索引，表示从字符串的末尾开始计算索引，例如 slice (-3, -1)，start 取不到 |
| substring(start, end)        | 从 start 位置开始，截取到 end 位置，end 取不到，基本和 slice 相同，但是不接受负值，如果传递了负数索引，则会将其视为 0 |

### replace () 方法

replace () 方法用于在字符串中用一些字符替换另一些字符。

其使用格式如下：

```js
replace(被替换的字符串, 要替换为的字符串)；
```

### split () 方法

split () 方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。

例如下面代码：

```js
var str = 'a,b,c,d';
console.log(str.split(','));// 返回的是一个数组 [a, b, c, d]
```

### 转换大小写

1.  `toUpperCase()` 方法将字符串中的所有字符转换为大写形式，并返回转换后的新字符串。
    
    ```js
    const str = "Hello, World!";
    const result = str.toUpperCase();
    console.log(result); // 输出 "HELLO, WORLD!"
    ```
    
2.  `toLowerCase()` 方法将字符串中的所有字符转换为小写形式，并返回转换后的新字符串。
    
    ```js
    const str = "Hello, World!";
    const result = str.toLowerCase();
    console.log(result); // 输出 "hello, world!"
    ```

# JavaScript 简单类型与复杂类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。

+   值类型：简单数据类型 / 基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型
    
    string，number，boolean，undefined，null
    
+   引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型
    
    通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等
    

## 堆和栈

堆栈空间分配区别：

1.  栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；简单数据类型存放到栈里面
2.  堆（操作系统）：存储复杂类型 (对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到堆里面

**注意**：JavaScript 中没有堆栈的概念，通过堆栈的方式，可以更容易理解代码的一些执行方式，便于将来学习其他语言。

## 简单类型的内存分配

+   值类型（简单数据类型）：string，number，boolean，undefined，null
+   值类型变量的数据直接存放在变量（栈空间）中

## 复杂类型的内存分配

+   引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等
+   引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中

## 简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部变量。

```js
function fn(a) {
    a++;
    console.log(a);// 11
}
var x = 10;
fn(x);
console.log(x);// 10
```

## 复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```js
function Person(name) {
    this.name = name;
}
function f1(x) {
    console.log(x.name);// 刘德华
    x.name = '张学友';
    console.log(x.name);// 张学友
}
var p = new Person('刘德华');
console.log(p.name);// 刘德华
f1(p);
console.log(p.name);// 张学友
```

